<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java数据结构梳理 | Yue C.H. Site</title><meta name="author" content="Yue C.H."><meta name="copyright" content="Yue C.H."><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  线性结构 线性结构特点  线性结构为最常用的数据结构，其特点是数据元素均为一对一的结构特点，即一个元素最多只有唯一后继，有且只有唯一前驱 线性结构有两种存储结构：  顺序存储（数组） ---&gt; 物理位置和逻辑位置是连续的 链式存储（链表） ---&gt; 物理位置不是连续的  线性结构对于检索的效率很低【数组，链表】  稀疏数组  稀疏数组介绍：当一个数组的大部分元素为0或为同">
<meta property="og:type" content="article">
<meta property="og:title" content="Java数据结构梳理">
<meta property="og:url" content="https://ychhh-1114.github.io/2022/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Yue C.H. Site">
<meta property="og:description" content="[TOC]  线性结构 线性结构特点  线性结构为最常用的数据结构，其特点是数据元素均为一对一的结构特点，即一个元素最多只有唯一后继，有且只有唯一前驱 线性结构有两种存储结构：  顺序存储（数组） ---&gt; 物理位置和逻辑位置是连续的 链式存储（链表） ---&gt; 物理位置不是连续的  线性结构对于检索的效率很低【数组，链表】  稀疏数组  稀疏数组介绍：当一个数组的大部分元素为0或为同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ychhh-1114.github.io/img/a.jpg">
<meta property="article:published_time" content="2022-03-15T07:22:11.000Z">
<meta property="article:modified_time" content="2024-04-14T09:54:33.438Z">
<meta property="article:author" content="Yue C.H.">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Data Struct">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ychhh-1114.github.io/img/a.jpg"><link rel="shortcut icon" href="/img/icon.ico"><link rel="canonical" href="https://ychhh-1114.github.io/2022/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"XO8L315K7G","apiKey":"2cd73df6ec19fdd7f3b0cab2fd056b89","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true  //是否显示滚动进度百分比,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java数据结构梳理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 17:54:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><style type="text/css">#toggle-sidebar {bottom: 80px}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/a.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_page.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Yue C.H. Site"><span class="site-name">Yue C.H. Site</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java数据结构梳理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-15T07:22:11.000Z" title="发表于 2022-03-15 15:22:11">2022-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T09:54:33.438Z" title="更新于 2024-04-14 17:54:33">2024-04-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java数据结构梳理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<hr />
<h3 id="线性结构">线性结构</h3>
<h4 id="线性结构特点">线性结构特点</h4>
<ul>
<li>线性结构为最常用的数据结构，其特点是数据元素均为<strong>一对一</strong>的结构特点，即<strong>一个元素最多只有唯一后继，有且只有唯一前驱</strong></li>
<li>线性结构有两种存储结构：
<ol type="1">
<li>顺序存储（数组） ---&gt; 物理位置和逻辑位置是连续的</li>
<li>链式存储（链表） ---&gt; 物理位置不是连续的</li>
</ol></li>
<li><strong>线性结构对于检索的效率很低【数组，链表】</strong></li>
</ul>
<h4 id="稀疏数组">稀疏数组</h4>
<ul class="task-list">
<li><p><label><input
type="checkbox" />稀疏数组介绍：当一个数组的大部分元素为0或为同一个值时，则若全部记录只会造成存储的数据大量的冗余，此时可以采用稀疏数组的存储方式进行存储</label></p></li>
<li><p><label><input type="checkbox" />稀疏数组的处理方法：</label></p>
<ol type="1">
<li>记录数组中不同值的个数以及数组的行数和列数</li>
<li>将不同值元素的行列值记录在一个表内，从而缩小数组的规模</li>
</ol></li>
<li><p><label><input type="checkbox" />```java package
LinearStruct;</label></p>
<p>import java.io.FileInputStream; import java.io.FileNotFoundException;
import java.io.FileOutputStream; import java.io.IOException; import
java.io.ObjectInputStream; import java.io.ObjectOutputStream;</p>
<p>import org.junit.jupiter.api.Test;</p>
<p>public class SparseMatrix {</p>
<p>static int matrix[][] = new int[3][3]; static { matrix[0][0] = 1;
matrix[2][2] = 2; }</p>
<p>static public int[][] constrMatrix() { int cnt = 0; for(int i = 0;i
&lt; matrix.length;i++) for(int j = 0;j &lt; matrix[0].length;j++)
if(matrix[i][j] != 0)cnt++; int sparse[][] = new int[cnt + 1][3]; int
index = 1;</p>
<pre><code>  sparse[0][0] = 3;
  sparse[0][1] = 3;

  for(int i = 0;i &lt; matrix.length;i++)
      for(int j = 0;j &lt; matrix[0].length;j++)
          if(matrix[i][j] != 0) &#123;
              sparse[index][0] = i;
              sparse[index][1] = j;
              sparse[index][2] = matrix[i][j];
              index++;
          &#125;
  for(int i = 1;i &lt;= cnt;i++)
      System.out.println(sparse[i][0] + &quot; &quot; + sparse[i][1] + &quot; &quot; + sparse[i][2]);

  System.out.println();
  return sparse;</code></pre>
<p>}</p>
<p>static public void returnMatrix(int [][]sparse) { int row =
sparse[0][0]; int col = sparse[0][1];</p>
<pre><code>  int mat[][] = new int[row][col];
  for(int i = 1;i &lt; sparse.length;i++) 
      mat[sparse[i][0]][sparse[i][1]] = sparse[i][2];



  for(int i = 0;i &lt; mat.length;i++) &#123;
      for(int j = 0;j &lt; mat[0].length;j++)
          System.out.print(mat[i][j] + &quot; &quot;);
      System.out.println();
  &#125;</code></pre>
<p>}</p>
<p>static public void saveMatrix(int sparse[][]) { FileOutputStream fos
= null; ObjectOutputStream oos = null;</p>
<pre><code>  try &#123;
      fos = new FileOutputStream(&quot;./mat.dat&quot;);
      oos = new ObjectOutputStream(fos);
      oos.writeObject(sparse);
  &#125; catch (FileNotFoundException e) &#123;
      // TODO Auto-generated catch block
      e.printStackTrace();
  &#125; catch (IOException e) &#123;
      // TODO Auto-generated catch block
      e.printStackTrace();
  &#125;finally &#123;
      try &#123;
          fos.close();
          oos.close();
      &#125; catch (IOException e) &#123;
          // TODO Auto-generated catch block
          e.printStackTrace();
      &#125;
  &#125;</code></pre>
<p>}</p>
<p>static public int[][] readMatrix(){ FileInputStream fis = null;
ObjectInputStream ois = null; int sparse[][] = null;</p>
<pre><code>  try &#123;
      fis = new FileInputStream(&quot;./mat.dat&quot;);
      ois = new ObjectInputStream(fis);
      sparse = (int[][])ois.readObject();
  &#125; catch (ClassNotFoundException | IOException e) &#123;
      // TODO Auto-generated catch block
      e.printStackTrace();
  &#125;finally &#123;
      try &#123;
          fis.close();
          ois.close();
      &#125; catch (IOException e) &#123;
          // TODO Auto-generated catch block
          e.printStackTrace();
      &#125;
  &#125;
  return sparse;</code></pre>
<p>}</p>
<p><span class="citation" data-cites="Test">@Test</span> public void
test() { // returnMatrix(constrMatrix()); saveMatrix(constrMatrix());
returnMatrix(readMatrix()); }</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br><br><br>#### 队列<br><br>- [ ] 队列为有序列表，可以用数组或链表来模拟实现<br>- [ ] 遵循先入先出的原则<br><br>##### 数组的队列模拟<br><br>- [ ] 数组模拟队列，即模拟的为有限队列，队列存在最大长度MaxSize<br><br>- [ ] 注意点<br><br>  - rear == MaxSize - 1时即队列已满<br>  - rear == head时队列为空<br>  - rear指向插入位置<br>  - head指向弹出位置<br><br>- [ ] ```java<br>  class ArrQueue&#123;<br>  	int head = -1;<br>  	int rear = -1;<br>  	<br>  	int maxSize = 0;<br>  	int queue[] = null;<br>  	<br>  	public ArrQueue(int size) &#123;<br>  		// TODO Auto-generated constructor stub<br>  		this.maxSize = size;<br>  		head = 0;<br>  		rear = 0;<br>  		queue = new int[size];<br>  	&#125;<br>  	<br>  	public boolean isEmpty() &#123;<br>  		if(this.queue == null || this.rear == this.head)return true;<br>  		else return false;<br>  	&#125;<br>  	<br>  	public int length() &#123;<br>  		return rear - head;<br>  	&#125;<br>  	<br>  	public int top() &#123;<br>  		if(!this.isEmpty()) <br>  			return queue[head];<br>  		else &#123;<br>  			System.out.println(&quot;empty queue!&quot;);<br>  			return -1;<br>  		&#125;<br>  	&#125;<br>  	<br>  	private boolean isFull() &#123;<br>  		if(this.rear == this.maxSize -1)return true;<br>  		else return false;<br>  	&#125;<br>  	<br>  	public int pop() &#123;<br>  		if(!this.isEmpty())return this.queue[head++];<br>  		else&#123;<br>  			System.out.println(&quot;empty queue&quot;);<br>  			return -1;<br>  		&#125;<br>  	&#125;<br>  	<br>  	public void push(int element) &#123;<br>  		if(!this.isFull())<br>  			queue[rear++] = element;<br>  		else<br>  			System.out.println(&quot;full queue&quot;);<br>  		<br>  	&#125;<br>  	<br>  	public Iterator iterator() &#123;<br>  		Iterator it = new MyIterator();<br>  		return it;<br>  	&#125;<br>  	<br>  	class MyIterator implements Iterator&#123;<br>  		int start = head;<br>  		@Override<br>  		public boolean hasNext() &#123;<br>  			// TODO Auto-generated method stub<br>  			if(start == rear)return false;<br>  			else return true;<br>  		&#125;<br>  		@Override<br>  		public Object next() &#123;<br>  			// TODO Auto-generated method stub<br>  			return queue[start++];<br>  		&#125;<br>  		<br>  		<br>  	&#125;<br>  	<br>  	<br>  	<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><label><input type="checkbox" />缺陷：</label></p>
<ul>
<li>不能充分利用数组的空间，pop后的位置无法再使用</li>
</ul>
<p>解决方法：</p>
<ul>
<li>构造循环队列</li>
</ul></li>
</ul>
<h5 id="数组循环队列">数组循环队列</h5>
<ul class="task-list">
<li><p><label><input type="checkbox" />循环队列的构建方法：</label></p>
<ul>
<li>head ---&gt; 指向队首</li>
<li>rear ---&gt; 指向将要push的位置，即空位置</li>
<li>此构建方法使得空出一个位置作为操作位，即无法push和pop的位置（真正的队尾位置）</li>
<li><strong>rear永远指向队列的空位置</strong></li>
</ul></li>
<li><p><label><input type="checkbox" />判断依据：</label></p>
<ul>
<li>当 <strong>rear == head</strong> 队列为空</li>
<li>当 <strong>(rear + 1) % MaxSize == head</strong>
队列为满【<strong>假的满队列，最后一个位置无法利用</strong>】</li>
<li>队列的元素个数：<strong>((rear + MaxSize) - head) %
MaxSize</strong></li>
</ul></li>
<li><p><label><input type="checkbox" />```java class CircleQueue{ int
head = -1; int rear = -1; int queue[] = null; int maxSize = 0; public
CircleQueue(int size) { // TODO Auto-generated constructor stub
this.maxSize = size; queue = new int[size]; this.head = 0; this.rear =
0; }</label></p>
<p>public boolean isEmpty() { if(rear == head)return true; return false;
}</p>
<p>public boolean isFull() { if(((rear + 1) % this.maxSize) ==
head)return true; else return false; }</p>
<p>public int pop() { int value = 0; if(!this.isEmpty()) { value =
queue[head]; head = (head + 1) % this.maxSize; return value; } else {
System.out.println("queue empty!"); return -1; }</p>
<p>}</p>
<p>public int top() { if(this.isEmpty()) { int value = this.queue[head];
head = (head + 1) % this.maxSize; return value; } else {
System.out.println("empty queue"); return -1; } }</p>
<p>public void push(int element) { if(!this.isFull()) { queue[rear] =
element; rear = (rear + 1) % this.maxSize; } else {
System.out.println("full queue!");</p>
<pre><code>  &#125;</code></pre>
<p>}</p>
<p>public Iterator iterator() { return new MyIterator(); }</p>
<p>class MyIterator implements Iterator{ int start = head; <span
class="citation" data-cites="Override">@Override</span> public boolean
hasNext() { // TODO Auto-generated method stub if(rear == start)return
false; else return true; } <span class="citation"
data-cites="Override">@Override</span> public Object next() { // TODO
Auto-generated method stub int value = queue[start]; start = (start + 1)
% maxSize; return value; } }</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>#### 链表<br><br>- [ ] 链表介绍：<br><br>  - 链表是以结点的方式进行存储的，每个结点包含data域和next域<br>  - 链表的各个结点并**不一定**是连续存放的<br>  - 链表区分带头节点和不带头节点的链表<br>- [ ] 头节点介绍：<br><br>  - 不存放具体数据<br>  - 作用就是表示链表的头部<br>- [ ] 在使用头节点的链表时，一般将头节点和Node结点分开两个类，而不是统一一个类进行操作<br><br>  - head ----&gt; SingleLinkedList<br>  - node ----&gt; Node<br>- [ ] 注意问题：<br>  - 对于有head的结点注意在add和delete时更新方式<br>  - 对于有rear的结点注意在什么时候更新rear(循环链表，双向循环链表)<br><br> ```mermaid<br>  classDiagram<br>  	SingleLinkedList &lt;|-- Node1<br>  	SingleLinkedList : Node head<br>  	Node1 &lt;|-- Node2<br>  	Node2 &lt;|-- Node3<br>  	Node3 &lt;|-- Node4<br>  <br></code></pre></td></tr></table></figure></li>
<li><p><label><input type="checkbox" />```java package
LinearStruct;</label></p>
<p>import java.util.Iterator;</p>
<p>import org.junit.jupiter.api.Test;</p>
<p>public class List { <span class="citation"
data-cites="Test">@Test</span> public void test() { SingleLinkedList
list = new SingleLinkedList(); list.addIndex(3, "ych"); list.addIndex(1,
"cqgg"); list.addIndex(10, "sss"); list.addIndex(0, "dwz");</p>
<pre><code>  list.set(1, &quot;sb&quot;);
  list.set(15, &quot;666&quot;);
  list.delete(20);
  list.delete(10);
  list.delete(1);
  list.delete(0);
  list.delete(3);

  Iterator iterator = list.iterator();
  while(iterator.hasNext())
      System.out.println(iterator.next());</code></pre>
<p>}</p>
<p>} class SingleLinkedList{ Node head = null; Node rear = null;</p>
<p>public void delete(int no) { if(head == null)return; if(head.no ==
no) { head = head.next; return; }</p>
<pre><code>  for(Node temp = head;temp.next !=  null;temp = temp.next) &#123;
      if(temp.next.no == no) &#123;
          temp.next = temp.next.next;
          return;
      &#125;
  &#125;
  System.out.println(&quot;not find&quot;);</code></pre>
<p>}</p>
<p>public void set(int no,String name) { if(head == null)return;</p>
<pre><code>  for(Node temp = head;temp != null;temp = temp.next)
      if(temp.no == no) &#123;
          temp.name = name;
          return;
      &#125;

  return;</code></pre>
<p>}</p>
<p>public void addIndex(int no,String name) { if(head == null) { Node
node = new Node(no, name); head = node; rear = node; } else { Node node
= new Node(no, name); if(no &lt; this.head.no) { node.next = this.head;
this.head = node; } else { Node temp = null; for(temp = head;temp.next
!= null;temp = temp.next) { if(no &lt; temp.next.no) { node.next =
temp.next; temp.next = node; return; } else continue; } temp.next =
node; return; } } }</p>
<p>public void addRear(int no,String name) { if(head == null) { Node
node = new Node(no, name); head = node; rear = node; } else { Node node
= new Node(no, name); rear.next = node; rear = node; } }</p>
<p>public void addRearTrav(int no,String name) { if(head == null) { Node
node = new Node(no, name); head = node; rear = node; } else { Node temp
= null; temp = this.head; while(temp.next != null) temp = temp.next;
Node node = new Node(no, name); temp.next = node; this.rear = node; }
}</p>
<p>public Iterator iterator() { return new MyIterator();</p>
<p>} class MyIterator implements Iterator{</p>
<pre><code>  Node front = head; 

  @Override
  public boolean hasNext() &#123;
      // TODO Auto-generated method stub
      if(front != null)return true;
      else return false;
  &#125;
  @Override
  public Object next() &#123;
      // TODO Auto-generated method stub
      Object value = front;
      front = front.next;
      return value;
  &#125;</code></pre>
<p>}</p>
<p>}</p>
<p>class Node{</p>
<p>int no; String name; Node next = null; public Node(int no,String
name) { // TODO Auto-generated constructor stub this.name = name;
this.no = no; }</p>
<p>public String toString() { return no + " " + name; }</p>
<p>} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>##### 链表注意点<br><br>- 在任何时刻都需要首先考虑头节点的问题<br><br>- 在**插入和删除时，temp结点踩到的永远是已经考虑过的结点**，此时需要考虑的是next结点，所以当temp.next == null时所以的结点就均被考虑过了，**而对于修改操作，temp踩到的点为未考虑过的点**，此时的全部考虑条件为temp == null，即对于增删操作需要找到其前一个点，而对于修改直接定位该点即可;<br><br>- 通过迭代器模式，更好的遍历结构体<br><br>- 被删除的结点无任何引用，会被JVM回收<br><br>  <br><br>##### 链表Question<br><br>- [ ] 链表的快速反转（挤牙膏算法）<br><br>  - 基本思路：挤牙膏：<br>    1. 设置temp为牙膏管<br>    2. 每次从temp挤出一个node（注意第一个挤出的node的next设为null）<br>    3. 将node采用头插法插到head之前<br>    4. 完成反转<br>    <br>  - ![](/img/picLib/inverse.png)<br><br>  - ![](/img/picLib/未命名绘图.png)<br><br>  - ![](/img/picLib/inverse2.png)<br><br>  - ```java<br>    public void inverse() &#123;<br>    		if(head == null || head.next == null)return;<br>    		<br>    		Node rear = head;<br>    		Node temp = head.next;<br>    		<br>    		rear.next = null;<br>    		<br>    		while(temp != null) &#123;<br>    			Node node = temp;<br>    			temp = temp.next;<br>    			<br>    			node.next = head;<br>    			head = node;<br>    		&#125;<br>    	&#125;<br></code></pre></td></tr></table></figure></p></li>
<li><p><label><input
type="checkbox" />实现单链表的反向输出：</label></p>
<ul>
<li>方法一：先将链表反转，在进行正向输出（破坏了原有链表的结构，不建议）</li>
<li>方法二：利用栈，将哥哥结点压入栈</li>
</ul></li>
</ul>
<h5 id="双向链表">双向链表</h5>
<ul class="task-list">
<li><p><label><input
type="checkbox" />对于每个结点都有两个指针：</label></p>
<ul>
<li>next ---&gt; 指向后一个结点</li>
<li>prior ---&gt; 指向前一个结点</li>
</ul></li>
<li><p><label><input type="checkbox" />```java public void
deleteDoubleList(int no) { if(no == head.no) { Node node = head.next;
node.prior = null; head = node; return; } else { for(Node temp =
head;temp.next != null;temp = temp.next) { if(no == temp.next.no) {
temp.next = temp.next.next; if(temp.next != null)temp.next.prior = temp;
return; } } } }</label></p>
<p>public void constrDoubleInTurn(int no,String name) { if(head == null)
{ Node node = new Node(no, name); head = node; node.next = null;
node.prior = null; return; } else { Node node = new Node(no, name);
if(no &lt; head.no) { node.next = head; head.prior = node; head = node;
rear = node; return; } else { Node temp = head; for(;temp.next !=
null;temp = temp.next) { if(no &lt; temp.next.no) { node.next =
temp.next; temp.next = node; node.prior = temp; node.next.prior = node;
return; } } temp.next = node; node.prior = temp; rear = node;</p>
<pre><code>      &#125;
  &#125;</code></pre>
<p>}</p>
<p>public void constrDoubleList(int no,String name) { if(head == null) {
Node node = new Node(no, name); head = node; node.next = null;
node.prior = null; return; } else { Node node = new Node(no, name); Node
temp = head; while(temp.next != null)temp = temp.next; temp.next = node;
node.prior = temp; return;</p>
<pre><code>  &#125;</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br><br><br><br><br>##### 循环链表<br><br>- [ ] 对于list额外除了head外额外设置rear指针，且对于rear指针需要在add和delete额外进行判断<br><br>- [ ] ```java<br>  Node head = null;<br>  	Node rear = null;<br>  	<br>  	public void deleteCircle(int no) &#123;<br>  		if(no == head.no) &#123;<br>  			if(head.next == head)head = null;<br>  			else &#123;<br>  				head = head.next;<br>  				rear.next = head;<br>  				<br>  			&#125;<br>  		&#125;<br>  		else &#123;<br>  			Node temp = head;<br>  			for(;temp.next != head;temp = temp.next) &#123;<br>  				if(no == temp.next.no) &#123;<br>  					temp.next = temp.next.next;<br>  					if(temp.next == head)rear = temp;<br>  					return;<br>  				&#125;<br>  			&#125;<br>  		&#125;<br>  		<br>  	&#125;<br>  	<br>  	public void circleListInTurn(int no,String name) &#123;<br>  		if(head == null) &#123;<br>  			Node node = new Node(no, name);<br>  			node.next = node;<br>  			head = node;<br>  			rear = node;<br>  		&#125;<br>  		else &#123;<br>  			Node node = new Node(no, name);<br>  			if(no &lt; head.no) &#123;<br>  				node.next = head;<br>  				head = node;<br>  				rear.next = head;<br>  			&#125;<br>  			else &#123;<br>  				Node temp = head;<br>  				for(;temp.next != head;temp = temp.next) &#123;<br>  					if(no &lt; temp.next.no) &#123;<br>  						node.next = temp.next;<br>  						temp.next = node;<br>  						return;<br>  					&#125;<br>  				&#125;<br>  				temp.next = node;<br>  				node.next = head;<br>  				rear = node;<br>  				<br>  			&#125;<br>  		&#125;<br>  			<br>  	&#125;<br>  	<br>  	<br>  	<br>  	<br></code></pre></td></tr></table></figure>
<ul class="task-list">
<li><label><input type="checkbox" />约瑟夫环问题：</label>
<ul>
<li>问题介绍：设置一个数m，一群人围城圈，从1开始依次报数，当报到m时，筛选出，下一个从1开始，以此类推，直到所有人退出</li>
<li>解决方法：通过循环链表，逐次delete结点，直到head == null结束</li>
</ul></li>
</ul></li>
</ul>
<h4 id="栈">栈</h4>
<ul class="task-list">
<li><label><input
type="checkbox" />数据结构特点：后入先出（LIFO）</label></li>
<li><label><input type="checkbox" />栈中的特殊指针：</label>
<ul>
<li>栈顶（Top）</li>
<li>栈底（Bottom）</li>
<li>元素的出入通过栈顶进行，栈底不变</li>
</ul></li>
</ul>
<h5 id="数组模拟栈">数组模拟栈</h5>
<ul class="task-list">
<li><p><label><input type="checkbox" />```java class ArrayStack{ private
int maxSize; private int []stack = null; private int top =
-1;</label></p>
<p>public ArrayStack(int size) { // TODO Auto-generated constructor stub
this.maxSize = size; stack = new int[size]; }</p>
<p>public boolean isFull() { return top == this.maxSize - 1; }</p>
<p>public boolean isEmpty() { return this.top == -1; }</p>
<p>public void push(int val) { if(!this.isFull()) { stack[++top] = val;
} }</p>
<p>public int pop() { if(!this.isEmpty()) { return stack[top--]; } else
throw new RuntimeException("stack empty!"); }</p>
<p>public Iterator iterator() { return new MyIterator(); }</p>
<p>class MyIterator implements Iterator{</p>
<pre><code>  int start = top;
  @Override
  public boolean hasNext() &#123;
      // TODO Auto-generated method stub
      return start != -1;
  &#125;
  @Override
  public Object next() &#123;
      // TODO Auto-generated method stub
      return stack[start--];
  &#125;</code></pre>
<p>}</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>##### 使用栈完成计算器<br><br>- [ ] 设置两个栈：<br>  - 数字栈<br>  - 符号栈<br>- [ ] 操作方式：<br>  - 如果是数字，直接压入数字栈<br>  - 如果是符号：<br>    1. 如果符号栈为空，直接进栈<br>    2. 如果符号优先级小于等于栈顶的符号使得优先级，则从数字栈中pop出两个数，从符号栈中pop出一个会数，进行计算，并将结果压入数字栈，将符号压入符号栈<br>       1. 如果当前的符号的优先级大于栈顶的符号优先级，符号直接入栈<br>  - 当扫描完毕，从数字栈和符号栈中pop出相应的数字和符号，并运行<br>  - 最后数字栈的结果就是计算结果<br><br><br><br><br><br>- [ ] ```mermaid<br>  classDiagram<br>  	Symbol &lt;|-- NumSymbol<br>  	Symbol &lt;|-- CalSymbol<br>  	<br>  	CalSymbol &lt;|-- Add<br>  	CalSymbol &lt;|-- Minus<br>  	CalSymbol &lt;|-- Multipul<br>  	CalSymbol &lt;|-- Division<br>  <br>  <br></code></pre></td></tr></table></figure></li>
<li><p><label><input type="checkbox" />- Symbol</label></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> LinearStruct.Cal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Symbol</span> &#123;<br><br>&#125;<br><span class="hljs-keyword">package</span> LinearStruct.Cal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalSymbol</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Symbol</span>,Comparable&#123;<br>	<span class="hljs-type">int</span> prior;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-type">CalSymbol</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> (CalSymbol)o;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.prior &lt; symbol.prior)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.prior == symbol.prior)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<br>	<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> NumSymbol <span class="hljs-title function_">calculate</span><span class="hljs-params">(NumSymbol v1,NumSymbol v2)</span>;<br>	<br>&#125;<br><span class="hljs-keyword">package</span> LinearStruct.Cal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumSymbol</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Symbol</span>&#123;<br>	<span class="hljs-type">int</span> value;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">NumSymbol</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-built_in">this</span>.value = val;<br>	&#125;<br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> String.valueOf(value);<br>	&#125;<br><br>&#125;<br><span class="hljs-keyword">package</span> LinearStruct.Cal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CalSymbol</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Add</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-built_in">this</span>.prior = <span class="hljs-number">1</span>;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> NumSymbol <span class="hljs-title function_">calculate</span><span class="hljs-params">(NumSymbol v1, NumSymbol v2)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumSymbol</span>(v1.value + v2.value);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">package</span> LinearStruct.Cal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Division</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CalSymbol</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Division</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-built_in">this</span>.prior = <span class="hljs-number">2</span>;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> NumSymbol <span class="hljs-title function_">calculate</span><span class="hljs-params">(NumSymbol v1, NumSymbol v2)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumSymbol</span>(v1.value / v2.value);<br>	&#125;<br><br>&#125;<br><span class="hljs-keyword">package</span> LinearStruct.Cal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Minus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CalSymbol</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Minus</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-built_in">this</span>.prior = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> NumSymbol <span class="hljs-title function_">calculate</span><span class="hljs-params">(NumSymbol v1, NumSymbol v2)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumSymbol</span>(v1.value - v2.value);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">package</span> LinearStruct.Cal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Multipul</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CalSymbol</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Multipul</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-built_in">this</span>.prior = <span class="hljs-number">2</span>;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> NumSymbol <span class="hljs-title function_">calculate</span><span class="hljs-params">(NumSymbol v1, NumSymbol v2)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumSymbol</span>(v1.value * v2.value);<br>	&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<ul>
<li>Client</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> LinearStruct.Cal;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.Stack;<br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">patternNum</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;[^0-9]&quot;</span>);<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">patternSym</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;//d*&quot;</span>);<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>	<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">minus</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;-&quot;</span>);<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;//+&quot;</span>);<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">multipul</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;//*&quot;</span>);<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">division</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;/&quot;</span>);<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> HashMap&lt;Pattern,Class&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>	<span class="hljs-keyword">static</span> &#123;<br>		map.put(minus, Minus.class);<br>		map.put(add, Add.class);<br>		map.put(multipul, Multipul.class);<br>		map.put(division, Division.class);<br>	&#125;<br>	<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getNumArr(String str) &#123;<br>		<span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> patternNum.matcher(str);<br>		<span class="hljs-type">String</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> m.replaceAll(<span class="hljs-string">&quot; &quot;</span>).trim();<br>		String numsStr[] = process.split(<span class="hljs-string">&quot; &quot;</span>);<br>		<span class="hljs-type">int</span> nums[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numsStr.length];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; numsStr.length;i++)<br>			nums[i] = Integer.parseInt(numsStr[i]);<br>		<span class="hljs-keyword">return</span> nums;<br>	&#125;<br>	<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> String[] getSyms(String str) &#123;<br>		<span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> patternSym.matcher(str);<br>		String syms[] = m.replaceAll(<span class="hljs-string">&quot; &quot;</span>).replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;&quot;</span>);<br>		<span class="hljs-keyword">return</span> syms;<br>	&#125;<br>	<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> CalSymbol <span class="hljs-title function_">consrtSym</span><span class="hljs-params">(String sym)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>		<span class="hljs-keyword">for</span>(Pattern p : map.keySet()) &#123;<br>			<span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.matcher(sym);<br>			<span class="hljs-keyword">if</span>(m.find())<br>				<span class="hljs-keyword">return</span> (CalSymbol) map.get(p).newInstance();<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">formatInput</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> sc.nextLine();<br>		String inputs[] = input.split(<span class="hljs-string">&quot;//s+&quot;</span>);<br>		<span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>		<span class="hljs-keyword">for</span>(String str : inputs)res += str;<br>		<span class="hljs-keyword">return</span> res;<br>		<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>		System.out.println(<span class="hljs-string">&quot;please input the expressionm : &quot;</span>);<br>		<span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> formatInput();<br>		<br>		<span class="hljs-type">int</span> nums[] = getNumArr(input);<br>		String syms[] = getSyms(input);<br><br>		<br>		Stack&lt;NumSymbol&gt; numStk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>		Stack&lt;CalSymbol&gt; symStk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;CalSymbol&gt;();<br>		<br>		ArrayList&lt;Symbol&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>		ArrayList&lt;NumSymbol&gt; numList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;NumSymbol&gt;();<br>		ArrayList&lt;CalSymbol&gt; symList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;CalSymbol&gt;();<br>		<br>		<span class="hljs-keyword">for</span>(Integer val : nums)<br>			numList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumSymbol</span>(val));<br>		<span class="hljs-keyword">for</span>(String str : syms) <br>			symList.add(consrtSym(str));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; symList.size();i++) &#123;<br>			list.add(numList.get(i));<br>			list.add(symList.get(i));<br>		&#125;<br>		list.add(numList.get(numList.size() - <span class="hljs-number">1</span>));<br>		<br>	<br>		<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; list.size();i++) &#123;<br>			<span class="hljs-keyword">if</span>(list.get(i) <span class="hljs-keyword">instanceof</span> NumSymbol) &#123;<br>				numStk.push((NumSymbol) list.get(i));<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-type">CalSymbol</span> <span class="hljs-variable">sym</span> <span class="hljs-operator">=</span> (CalSymbol)list.get(i);<br>				<span class="hljs-keyword">if</span>(symStk.isEmpty())symStk.push(sym);<br>				<span class="hljs-keyword">else</span> &#123;<br>					<span class="hljs-type">CalSymbol</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> symStk.peek();<br>					<span class="hljs-keyword">if</span>(sym.compareTo(top) &gt; <span class="hljs-number">0</span>)symStk.push(sym);<br>					<span class="hljs-keyword">else</span> &#123;<br>						<span class="hljs-type">NumSymbol</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> numStk.pop();<br>						<span class="hljs-type">NumSymbol</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> numStk.pop();<br>						<span class="hljs-type">CalSymbol</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> symStk.pop();<br>						numStk.push(cal.calculate(v2, v1));<br>						symStk.push(sym);<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<br>		<span class="hljs-type">int</span> <span class="hljs-variable">epoch</span> <span class="hljs-operator">=</span> symStk.size();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; epoch;i++) &#123;<br>			<span class="hljs-type">NumSymbol</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> numStk.pop();<br>			<span class="hljs-type">NumSymbol</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> numStk.pop();<br>			<span class="hljs-type">CalSymbol</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> symStk.pop();<br>			numStk.push(cal.calculate(v2, v1));<br>		&#125;<br>		<br>		<br>		System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + numStk.pop());<br>		<br>		<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="前缀-中缀-后缀表达式">前缀 / 中缀 / 后缀表达式</h5>
<h6 id="前缀表达式波兰表达式">前缀表达式（波兰表达式）</h6>
<ul class="task-list">
<li><label><input
type="checkbox" />前缀表达式扫描顺序：从右至左，最右边为数字，最左边为符号</label></li>
</ul>
<h6 id="中缀表达式">中缀表达式</h6>
<ul class="task-list">
<li><label><input
type="checkbox" />最易人理解的表达式，但是不易计算机理解，原因是因为优先级的存在</label></li>
<li><label><input
type="checkbox" />在计算机计算时一般情况下将中缀表达式转化为<strong>后缀表达式</strong></label></li>
</ul>
<h6 id="后缀表达式逆波兰表达式">后缀表达式（逆波兰表达式）</h6>
<ul class="task-list">
<li><p><label><input
type="checkbox" />后缀表达式扫描顺序：从左至右扫描，对应符号跟在数字之后</label></p></li>
<li><p><label><input type="checkbox" />实现逆波兰计算器</label></p>
<ul>
<li><p>```java package LinearStruct.ReversePolish;</p>
<p>import java.util.ArrayList; import java.util.Scanner; import
java.util.Stack;</p>
<p>public class ReversePolishCal {</p>
<pre><code>static public Scanner sc = new Scanner(System.in);

static public ArrayList&lt;String&gt; getList(String input)&#123;
    String strs[] = input.split(&quot; &quot;);
    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
    for(String str : strs)
        list.add(str);
    return list;
&#125;

static public void calPost(String input) &#123;

    ArrayList&lt;String&gt; list = getList(input);
    Stack&lt;String&gt; stk = new Stack();

    for(String str : list) &#123;
        if(str.matches(&quot;//d+&quot;))stk.push(str);
        else &#123;
            int v1 = Integer.parseInt(stk.pop());
            int v2 = Integer.parseInt(stk.pop());
            if(str.equals(&quot;+&quot;))stk.push(String.valueOf(v2 + v1));
            else if(str.equals(&quot;-&quot;))stk.push(String.valueOf(v2 - v1));
            else if(str.equals(&quot;*&quot;))stk.push(String.valueOf(v2 * v1));
            else stk.push(String.valueOf(v2 / v1));
        &#125;
    &#125;


    System.out.println(&quot;result: &quot; + stk.pop());
&#125;</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    <br>  <br>- [ ] 中缀表达式转后缀表达式<br><br>  - 步骤：<br><br>  &gt; 1. 设置两个栈，一个为符号栈，一个为输出栈（即最终的后缀表达式的栈）<br>  &gt; 2. 若遇到数字，则压入输出栈<br>  &gt; 3. 若遇到符号：<br>  &gt;    - 括号“（） ”不参与符号优先级比较<br>  &gt;    - 符号栈顶为空，或符号栈顶为左括号，或优先级高于栈顶优先级，则压入符号栈<br>  &gt;    - 若符号优先级小于符号栈顶的优先级，则将符号栈顶的符号弹至输出栈，并再次比较当前符号与新符号栈顶符号的优先级<br>  &gt;    - 若遇到左括号，直接压入符号栈<br>  &gt;    - 若遇到右括号，则依次弹出符号栈顶的符号，压入输出栈，直到遇到左括号，将左括号弹出丢弃，此时完成了一个括号的去除<br>  &gt; 4. 最后将符号栈的元素依次弹出至输出栈<br>  &gt; 5. 获得后缀表达式的逆序，再将表达式反转即得到最终会的后缀表达式<br><br>  - ```java<br>    package LinearStruct.ReversePolish;<br>    <br>    import java.util.ArrayList;<br>    import java.util.HashMap;<br>    import java.util.Scanner;<br>    import java.util.Stack;<br>    import java.util.regex.Matcher;<br>    import java.util.regex.Pattern;<br>    <br>    public class NifixToPost &#123;<br>    	static public Scanner sc = new Scanner(System.in);<br>    <br>    	static public HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();<br>    	static &#123;<br>    		map.put(&quot;+&quot;, 1);<br>    		map.put(&quot;-&quot;, 1);<br>    		map.put(&quot;*&quot;, 2);<br>    		map.put(&quot;/&quot;, 2);<br>    	&#125;<br>    	<br>    	static public ArrayList&lt;String&gt; getList(String input) &#123;<br>    		String all[] = input.split(&quot;&quot;);<br>    		ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<br>    		for(int i = 0;i &lt; all.length;i++) &#123;<br>    			if(all[i].matches(&quot;//d+&quot;))&#123;<br>    				int j = i + 1;<br>    				String val = all[i];<br>    				while(j &lt; all.length) &#123;<br>    					if(all[j].matches(&quot;//d+&quot;))val += all[j++];<br>    					else &#123;<br>    						i = j - 1;<br>    						break;<br>    					&#125;<br>    				&#125;<br>    				list.add(val);<br>    			&#125;<br>    			else list.add(all[i]);<br>    		&#125;<br>    		<br>    		return list;<br>    	&#125;<br>    	<br>    	<br>    	public static String formatInput() &#123;<br>    		System.out.println(&quot;pleas input the expression: &quot;);<br>    		String input = sc.nextLine();<br>    		String ins[] = input.split(&quot;//s+&quot;);<br>    		String res = &quot;&quot;;<br>    		for(String str : ins)<br>    			res += str;<br>    		return res;<br>    	&#125;<br>    <br>    	<br>    	public static void main(String[] args) &#123;<br>    		String input = formatInput();<br>    		ArrayList&lt;String&gt; list = getList(input);<br>    		Stack&lt;String&gt; out = new Stack&lt;String&gt;();<br>    		Stack&lt;String&gt; symStk = new Stack&lt;String&gt;();<br>    //		System.out.println(3);<br>    		for(String str : list) &#123;<br>    			if(str.matches(&quot;//d+&quot;)) out.push(str);<br>    			else &#123;<br>    				if(symStk.isEmpty() || str.equals(&quot;(&quot;))symStk.push(str);<br>    				else &#123;<br>    					if(str.equals(&quot;)&quot;)) &#123;<br>    						while(true) &#123;<br>    							String top = symStk.pop();<br>    							if(top.equals(&quot;(&quot;))break;<br>    							else out.push(top);<br>    						&#125;<br>    					&#125;<br>    					else &#123;<br>    						String top = symStk.peek();<br>    						if(top.equals(&quot;(&quot;) || (map.get(str) &gt; map.get(top)))symStk.push(str);<br>    						else &#123;<br>    							while(true) &#123;<br>    								String sym = symStk.peek();<br>    								if(symStk.isEmpty() || (map.get(str) &gt; map.get(sym))) &#123;<br>    									symStk.push(str);<br>    									break;<br>    								&#125;<br>    								else out.push(symStk.pop());<br>    							&#125;<br>    						&#125;<br>    					&#125;<br>    					<br>    				&#125;<br>    			&#125;<br>    		&#125;<br>    //		System.out.println(6);<br>    		<br>    		while(!symStk.isEmpty())<br>    			out.push(symStk.pop());<br>    		<br>    		StringBuffer transVal = new StringBuffer();<br>    		while(!out.isEmpty())<br>    			transVal.append(out.pop() + &quot; &quot;);<br>    		<br>    		transVal = transVal.reverse();<br>    		String postVal = transVal.toString().trim();<br>    		<br>    		ReversePolishCal.calPost(postVal);<br>    		<br>    	&#125;<br>    	<br>    	<br>    &#125;<br>    <br></code></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="递归recursion">递归（Recursion）</h4>
<ul class="task-list">
<li><label><input type="checkbox" />介绍：</label>
<ul>
<li>递归即函数自己调用自己，从而达到简化代码的结果</li>
<li>每次执行一个函数就会开辟一个栈区来存储局部变量</li>
<li>每个区域的变量是独立的</li>
<li>递归必须先考虑临界条件，否则容易造成栈溢出</li>
</ul></li>
</ul>
<h5 id="迷宫问题">迷宫问题</h5>
<ul class="task-list">
<li><p><label><input
type="checkbox" />找到一条路（不一定是最短路，此处给出代码仅为普通递归（或者理解为dfs），而非bfs）</label></p>
<ul>
<li><p>```java package LinearStruct.Recursion;</p>
<p>import org.junit.jupiter.api.Test;</p>
<p>public class Maze {</p>
<pre><code>public int[][] way = null;
static public boolean flag = false;


public int[][] copy(int map[][])&#123;
    int temp[][] = new int[8][7];

    for(int i = 0;i &lt; map.length;i++)
        for(int j = 0;j &lt; map[1].length;j++)
            temp[i][j] = map[i][j];
    return temp;
&#125;

public void findWay(int map[][],int r,int c) &#123;
    /* u up
     * d down
     * l left
     * r right
     * 
     * */

    System.out.println(r + &quot; &quot; + c);
    if(map[r + 1][c] == 6 || map[r - 1][c] == 6 || map[r][c + 1] == 6 || map[r][c - 1] == 6) &#123;
        way = copy(map);
        flag = true;
        return;
    &#125;
    else &#123;
        if(map[r + 1][c] != 1 &amp;&amp; map[r + 1][c] != 2 &amp;&amp; !flag) &#123;
            int temp[][] = copy(map);
            temp[r + 1][c] = 2;
            findWay(temp,r + 1,c);
        &#125;

        if(map[r][c + 1] != 1 &amp;&amp; map[r][c + 1] != 2 &amp;&amp; !flag) &#123;
            int temp[][] = copy(map);
            temp[r][c + 1] = 2;
            findWay(temp,r,c + 1);
        &#125;

        if(map[r - 1][c] != 1 &amp;&amp; map[r - 1][c] != 2 &amp;&amp; !flag) &#123;
            int temp[][] = copy(map);
            temp[r - 1][c] = 2;
            findWay(temp,r - 1,c);
        &#125;


        if(map[r][c - 1] != 1 &amp;&amp; map[r][c - 1] != 2 &amp;&amp; !flag) &#123;
            int temp[][] = copy(map);
            temp[r][c - 1] = 2;
            findWay(temp,r,c + 1);
        &#125;
    &#125;


&#125;

@Test
public void test() &#123;
    int map[][] = new int[8][7];
    for(int i = 0;i &lt; 8;i++) &#123;
        map[i][0] = 1;
        map[i][6] = 1;
        if(i &lt;= 6) &#123;
            map[0][i] = 1;
            map[7][i] = 1;
        &#125;

    &#125;
    map[3][1] = 1;
    map[3][2] = 1;
    map[3][3] = 2;
    map[6][5] = 6;
    for(int i = 0;i &lt; 8;i++) &#123;
        for(int j = 0;j &lt; 7;j++)
            System.out.print(map[i][j] + &quot; &quot;);
        System.out.println();
    &#125;
    findWay(map,3,3);

    for(int i = 0;i &lt; 8;i++) &#123;
        for(int j = 0;j &lt; 7;j++)
            System.out.print(way[i][j] + &quot; &quot;);
        System.out.println();
    &#125;</code></pre>
<p>//</p>
<pre><code>&#125;</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>- [ ] 若要找到最短路需要使用bfs算法<br><br><br><br>##### 八皇后问题<br><br>- [ ] 问题介绍：<br><br>  - 8个皇后<br>  - 8 * 8棋盘<br><br>  - 对于所有的皇后不能在一条直线，一条竖线，一条对角线<br><br>- [ ] 基本思路：<br><br>  - 既然8*8棋盘，8个皇后，所以每个皇后必然独占一行，因此只需按照行进行递归判断即可<br>  - 基本思路依然为dfs<br><br>- [ ] ```java<br>  package LinearStruct.ReversePolish;<br>  <br>  import org.junit.jupiter.api.Test;<br>  <br>  public class EightQueens &#123;<br>  	<br>  	static public int cnt = 0;<br>  	public void show(int map[][]) &#123;<br>  		System.out.println(&quot;no.&quot; + cnt);<br>  		for(int i = 0;i &lt; 8;i++) &#123;<br>  			for(int j = 0;j &lt; 8;j++)<br>  				System.out.print(map[i][j] + &quot; &quot;);<br>  			System.out.println();<br>  		&#125;<br>  		System.out.println(&quot;-------------------------------&quot; + &quot;/n&quot;);<br>  	&#125;<br>  	public void queens(int map[][],int row) &#123;<br>  		if(row == 8) &#123;<br>  			cnt++;<br>  			show(map);<br>  			return;<br>  		&#125;<br>  		else &#123;<br>  			for(int j = 0;j &lt; 8;j++) &#123;<br>  				for(int k = 0;k &lt; 8;k++)<br>  					map[row][k] = 0;<br>  				<br>  				if(row == 0) &#123;<br>  					map[0][j] = 1;<br>  					queens(map,row + 1);<br>  				&#125;<br>  				else &#123;<br>  					boolean flag = false;<br>  					for(int i = 0;i &lt; row;i++)<br>  						if(map[i][j] == 1) &#123;<br>  							flag = true;<br>  							break;<br>  						&#125;<br>  					if(flag)continue;<br>  					for(int r = row - 1,init = j - 1;r &gt;= 0 &amp;&amp; init &gt;= 0;r--,init--)<br>  						if(map[r][init] == 1) &#123;<br>  							flag = true;<br>  							break;<br>  						&#125;<br>  					for(int r = row - 1,init = j + 1;r &gt;= 0 &amp;&amp; init &lt; 8;r--,init++)<br>  						if(map[r][init] == 1) &#123;<br>  							flag = true;<br>  							break;<br>  						&#125;<br>  					<br>  					if(flag)continue;<br>  					map[row][j] = 1;<br>  					queens(map,row + 1);<br>  					<br>  				&#125;<br>  			&#125;<br>  		&#125;<br>  		<br>  	&#125;<br>  	<br>  	<br>  	@Test<br>  	public void test() &#123;<br>  		int map[][] = new int[8][8];	<br>  		queens(map,0);<br>  		System.out.println(cnt);<br>  	&#125;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="排序算法">排序算法</h3>
<h4 id="排序种类">排序种类</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />内部排序：</label></p>
<ul>
<li><p>数据量适中，可以一次性加载到内存进行排序</p></li>
<li><p>排序方法：</p>
<ol type="1">
<li><p>插入排序：</p>
<blockquote>
<ol type="1">
<li>直接插入排序</li>
<li>希尔排序</li>
</ol>
</blockquote></li>
<li><p>选择排序</p>
<blockquote>
<ol type="1">
<li>简单选择排序</li>
<li>堆排序</li>
</ol>
</blockquote></li>
<li><p>交换排序</p>
<blockquote>
<ol type="1">
<li>冒泡排序</li>
<li>快速排序</li>
</ol>
</blockquote></li>
<li><p>归并排序</p></li>
<li><p>基数排序（桶排序）</p></li>
<li><p>堆排序【<strong>放在树中详述</strong>】</p></li>
</ol></li>
</ul></li>
<li><p><label><input type="checkbox" />外部排序：</label></p>
<ul>
<li>数据量过大无法全部加载到内存进行排序，需要借助外部存储进行排序</li>
</ul></li>
</ul>
<h4 id="算法时间复杂度统计方法">算法时间复杂度统计方法</h4>
<ul class="task-list">
<li><label><input type="checkbox" />事后统计法</label>
<ul>
<li>在程序运行过后进行时间的统计</li>
</ul></li>
<li><label><input type="checkbox" />事前估计法</label>
<ul>
<li>统计时间复杂度</li>
<li>T(n) = O(n)【采用了极限的思想】：
<ol type="1">
<li>忽略常数项</li>
<li>忽略低次项</li>
<li>忽略项系数</li>
</ol></li>
</ul></li>
<li><label><input type="checkbox" />T(n)
为多项式表达式，f(n)为T(n)的同阶系数为1的单项式 ==》T(n) =
O(f(n))</label></li>
</ul>
<h5 id="平均时间复杂度">平均时间复杂度</h5>
<h5 id="最坏时间复杂度">最坏时间复杂度</h5>
<ul class="task-list">
<li><label><input
type="checkbox" />算法在考虑时间复杂度时考虑最坏时间复杂度</label></li>
</ul>
<h4 id="冒泡排序">冒泡排序</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本思想：</label></p>
<ul>
<li>扫描序列，依次查看相邻的元素的值，如果出现逆序则进行交换，使较大的值移向尾部(<strong>由此看出冒泡排序是稳定的排序算法</strong>)</li>
<li><strong>冒泡优化：当一趟扫描后从来未进行交换则说明已经有序，通过设置index位来标识是否进行排序，从而降低一定的时间复杂度</strong></li>
<li>理解：
<ol type="1">
<li>i即外层指向的位置为此次排序一定能确定的位置</li>
<li>j从0遍历到i - 1，若有逆序进行交换</li>
<li>index确定上一次交换的位置，若无交换则为-1【index =
-1表示数组有序，index =
1表示上一次交换的为第一个位置，交换后数组有序】，若index不为-1则i =
index，下一次i从最后依次交换的位置开始</li>
</ol></li>
</ul></li>
<li><p><label><input type="checkbox" />图解：</label></p>
<p><img src="/img/picLib/bublesort.png" /></p></li>
<li><p><label><input type="checkbox" />```java public class BubleSort
{</label></p>
<pre><code>//基本buble sort </code></pre>
<p>static public void sort(int arr[]) {</p>
<pre><code>  int cnt = arr.length - 1;
  for(int i = cnt;i &gt;= 0;i--) &#123;
      for(int j = 0;j &lt; i;j++) 
          if(arr[j] &gt; arr[j + 1]) &#123;
              int temp = arr[j];
              arr[j] = arr[j + 1];
              arr[j + 1] = temp;
          &#125;
  &#125;</code></pre>
<p>}</p>
<pre><code>// 加如index后</code></pre>
<p>static public void sortOpt(int arr[]) { int cnt = arr.length - 1;
for(int i = cnt;i &gt;= 1;i--) { int index = -1; for(int j = 0;j &lt;
i;j++) if(arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j +
1]; arr[j + 1] = temp; index = j;</p>
<pre><code>          &#125;

      if(index == -1)break;
      else i = index + 1; //此处为index + 1 not index呦嘻嘻
  &#125;</code></pre>
<p>}</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br><br><br>#### 选择排序<br><br>- [ ] 每次找到当前索引至数组尾部最小/最大的元素放在指定的位置<br><br>- [ ] 基本思想：<br><br>  - 每次确定arr[i]位置的元素<br>  - i 之前的位置均为已确定的元素<br>  - j从i + 1开始,只要arr[j] &lt; arr[i]就交换两个位置上的元素<br><br>- [ ] 选择排序的不稳定性：<br><br>  ![](/img/picLib/selection.png)<br><br>- [ ] ```java<br>  package SortAlgorithm;<br>  <br>  public class SelectionSort &#123;<br>  	<br>  	static public void sort(int arr[]) &#123;<br>  		for(int i = 0;i &lt; arr.length;i++) &#123;<br>  			for(int j = i + 1;j &lt; arr.length;j++)<br>  				if(arr[j] &lt; arr[i]) &#123;<br>  					int temp = arr[j];<br>  					arr[j] = arr[i];<br>  					arr[i] = temp;<br>  				&#125;<br>  			<br>  		&#125;<br>  	&#125;<br>  <br>  &#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="插入排序">插入排序</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本介绍：</label></p>
<ul>
<li>进行循环，在每一次循环在i之前的为有序列表，在之后的为无需列表</li>
<li>实则即为找到合适的位置进行交换元素,通过相邻交换的思想实现插入的方法</li>
<li>使得每一次使arr[i]的元素在其正确的位置</li>
</ul></li>
<li><p><label><input type="checkbox" />分类：</label></p>
<ul>
<li><p>交换式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span> &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; arr.length;i++) &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;j &gt; <span class="hljs-number">0</span>;j--)<br>				<span class="hljs-keyword">if</span>(arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>					<span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>					arr[j] = arr[j - <span class="hljs-number">1</span>];<br>					arr[j - <span class="hljs-number">1</span>] = temp;<br>				&#125;<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>		&#125;<br>		<br>	&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>移位式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span> &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; arr.length;i++) &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>			<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>			<span class="hljs-keyword">if</span>(arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>				<span class="hljs-keyword">while</span>(j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>					arr[j] = arr[j - <span class="hljs-number">1</span>];<br>					j -= <span class="hljs-number">1</span>;<br>					<br>				&#125;<br>				arr[j] = temp;<br>				<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br></code></pre></td></tr></table></figure></li>
<li><p><strong>移位式排序算法要快于交换式的排序算法：移位的过程中只需要覆盖而不需要替换，而交换时的排序算法即需要进行覆盖也需要进行元素的替换</strong></p></li>
<li><p>对于插入算法，不管是移位式还是交换式算法都是稳定的排序算法</p></li>
</ul></li>
<li><p><label><input type="checkbox" />插入排序缺点：</label></p>
<ul>
<li>当插入的数较小时，需要多次的交换和比较</li>
</ul></li>
</ul>
<h4 id="希尔排序">希尔排序</h4>
<ul class="task-list">
<li><p><label><input
type="checkbox" />希尔排序也是一种插入排序，简单插入排序的优化算法，也称<strong>缩小增量排序</strong></label></p></li>
<li><p><label><input type="checkbox" />基本思想：</label></p>
<ul>
<li>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</li>
<li>随着增量的减少每组包含的关键词增多，当增量减至1时，整个文件被分为1组，算法终止</li>
<li>即<strong>分组 + 插入排序</strong></li>
</ul></li>
<li><p><label><input type="checkbox" />类型：</label></p>
<ul>
<li><p>交换式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">for</span>(;gap &gt; <span class="hljs-number">0</span>;gap /= <span class="hljs-number">2</span>) &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap;i &lt; arr.length;i++) &#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - gap;j &gt;= <span class="hljs-number">0</span>;j -= gap) &#123;<br>					<span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + gap]) &#123;<br>						<span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>						arr[j] = arr[j + gap];<br>						arr[j + gap] = temp;<br>					&#125;<br>				&#125;<br>					<br>			&#125;<br>				<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>移位式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortSwapShell</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span> &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>;gap &gt; <span class="hljs-number">0</span>;gap /= <span class="hljs-number">2</span>) &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap;i &lt; arr.length;i++) &#123;<br>				<span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>				<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>				<span class="hljs-keyword">if</span>(temp &lt; arr[i - gap]) &#123;<br>					<span class="hljs-keyword">while</span>(j - gap &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;<br>						arr[j] = arr[j - gap];<br>						j -= gap;<br>					&#125;<br>					arr[j] = temp;<br>						<br>				&#125;<br>			&#125;<br>		&#125;<br>		<br>	&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p><strong>移位式的平均排序速度要快于交换式</strong></p></li>
</ul></li>
<li><p><label><input
type="checkbox" />虽然希尔排序底层依然是插入排序但是插入排序是稳定的而希尔排序是不稳定的</label></p></li>
</ul>
<h4 id="快速排序">快速排序</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本思想：</label></p>
<ul>
<li>快排是对冒泡排序的一种改进</li>
<li>原理：
<ol type="1">
<li>先经过一趟排序，将数组分成两部分，以一个数为基准，比一个数小的所有元素放在左侧，比一个数大的所有元素放在右侧</li>
<li>对左右两侧的元素递归的使用快速排序</li>
<li>即每次执行一遍sort至少 <strong>确定1/2的元素范围 +
1个确切的元素位置</strong></li>
</ol></li>
<li>主要：
<ol type="1">
<li>设置每个数字的第一个元素为确定pos</li>
<li>为什么要确定第一个数？
<ul>
<li>使得right--可以收敛【要么<strong>right &lt;
left</strong>，要么<strong>right ==
left</strong>（即第一个元素的位置已经对了）】</li>
</ul></li>
<li>因为选择的最左端，所以利用right--进行收敛</li>
</ol></li>
</ul></li>
<li><p><label><input type="checkbox" />```java package
SortAlgorithm;</label></p>
<p>import java.util.Arrays;</p>
<p>public class QuickSort { // 2 1 5 2 6</p>
<p>static public void swap(int arr[],int pos1,int pos2) { int temp =
arr[pos1]; arr[pos1] = arr[pos2]; arr[pos2] = temp;</p>
<p>} //2 1 5 2 6</p>
<p>static public int partation(int arr[],int left,int right) { int value
= arr[left]; int l = left; int r = right + 1; while(true) {
while(arr[++l] &lt; value &amp;&amp; l &lt; right); while(arr[--r] &gt;
value &amp;&amp; r &gt; left); if(l &lt; r) swap(arr,l,r); else break; }
swap(arr,r,left); return r; }</p>
<p>// 在快排中一个重要的问题就是left和right是否可以取到！ //
另一个问题是对于重复元素的判断 static public void sort(int arr[],int
left,int right) { if(left &lt; right) { int pos = partation(arr, left,
right);</p>
<pre><code>      sort(arr,left,pos - 1);
      sort(arr,pos + 1,right);
  &#125;
  else return;</code></pre>
<p>} }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>**上下对比【partation】**<br><br>- [ ] ```java<br>  <br>  	static public int partation(int arr[],int left,int right) &#123;<br>  		int value = arr[right];<br>  		int l = left;<br>  		int r = right - 1;<br>  		while(true) &#123;<br>  			while(l &lt; right &amp;&amp; arr[l] &lt; value)l++;<br>  			while(r &gt; left &amp;&amp; arr[r] &gt; value)r--;<br>  			if(l &lt; r)<br>  				swap(arr,l,r);<br>  			else break;<br>  		&#125;<br>  		swap(arr,l,right);<br>  		return l;<br>  	&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>此方法与上面的方法进行对比可以发现，若设置左边为收敛位置，则需要使用右边进行默认的交换，反之，若要设置右边为收敛位置则需要左边为默认交换</li>
</ul>
</blockquote></li>
</ul>
<h4 id="归并排序">归并排序</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本原理：</label></p>
<ul>
<li>采用了分治策略:
<ol type="1">
<li>分割数组</li>
<li>合并有序</li>
</ol></li>
<li>分至末层，使得两个有序，再进行合并，合并有序序列</li>
</ul></li>
<li><p><label><input type="checkbox" />类型：</label></p>
<ul>
<li>递归法</li>
<li>非递归法</li>
<li><strong>递归和非递归思想均为分治策略，但是实际的逻辑顺序不同</strong></li>
</ul></li>
<li><p><label><input type="checkbox" />```java package
SortAlgorithm;</label></p>
<p>public class MergeSort {</p>
<p>static public void copy(int cpy[],int arr[],int left,int right) { int
index = 0; for(int i = left;i &lt;= right;i++) arr[i] = cpy[index++];
}</p>
<p>static public void merge(int arr[],int left,int mid,int right) { int
copy[] = new int[right - left + 1]; int i = 0; int p1 = left; int p2 =
mid + 1; while(p1 != mid + 1 &amp;&amp; p2 != right + 1) { if(arr[p1]
&lt; arr[p2])copy[i++] = arr[p1++]; else if(arr[p1] &gt;=
arr[p2])copy[i++] = arr[p2++]; } if(p1 &gt; mid) for(int p = p2;p &lt;=
right;p++) copy[i++] = arr[p]; else for(int p = p1;p &lt;= mid;p++)
copy[i++] = arr[p];</p>
<pre><code>  copy(copy,arr,left,right);</code></pre>
<p>}</p>
<p>static public void sort(int arr[],int left,int right) { if(left &lt;
right) { int mid = (left + right) / 2; sort(arr,left,mid); sort(arr,mid
+ 1,right); merge(arr,left,mid,right); } }</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br><br><br><br><br>#### 基数排序（桶排序）<br><br>- [ ] 基本介绍：<br>  - 基数排序（radix sort）又称分配式排序（distribute sort）或桶排序（bucket sort）<br>  - 通过键值的各个位置的值，将要排序的元素分配至某些桶中去，从而达到排序的效果<br>  - 基数排序属于稳定的排序算法，且效率较高<br>  - 基数排序是桶排序的扩展<br>  <br>- [ ] 基本思想：<br>  - 将所有待比较的数统一为同样的数位长度，数位较短的数前面补0，然后从最低为开始，依次进行一次排列。这样从最低为排序到最高位排序以后，数列变为一个有序的数列<br>  <br>  - **典型的以空间换时间的算法**<br>  <br>  - 时间复杂度 ： n * maxLength<br>  <br>  - 优先级：<br>  <br>    1. 最高位的值<br>    2. 数值的位数<br>  <br>  - **基数排序不可进行含有负数的排序【缺点】**<br>  <br>    <br>  <br>- [ ] ```java<br>  package SortAlgorithm;<br>  <br>  import java.util.Arrays;<br>  <br>  public class RadixSort &#123;<br>  	<br>  	static public void sort(int arr[]) &#123;<br>  		StringBuilder nums[] = new StringBuilder[arr.length];<br>  		int maxLen = 0;<br>  		for (int i = 0; i &lt; nums.length; i++) &#123;<br>  			nums[i] = new StringBuilder(String.valueOf(arr[i])).reverse();<br>  			if(maxLen &lt; nums[i].length())<br>  				maxLen = nums[i].length();<br>  		&#125;<br>  		<br>  		StringBuilder bucket[][] = new StringBuilder[10][arr.length];<br>  		<br>  		int point = 0;<br>  		<br>  		while(point &lt; maxLen) &#123;<br>  			<br>  			int cnt[] = new int[10];<br>  			<br>  			for(StringBuilder num : nums)<br>  				if(num.length() &gt; point) &#123;<br>  					int pos = Integer.parseInt(String.valueOf(num.charAt(point)));<br>  					bucket[pos][cnt[pos]++] = num;<br>  				&#125;<br>  				else bucket[0][cnt[0]++] = num;<br>  			<br>  			int index = 0;<br>  			System.out.println(Arrays.toString(cnt));<br>  			for(int i = 0;i &lt;= 9;i++)<br>  				for(int j = 0;j &lt; cnt[i];j++) <br>  					nums[index++] = bucket[i][j];<br>  			point++;<br>  				<br>  		&#125;<br>  		<br>  		for(int i = 0;i &lt; arr.length;i++)<br>  			arr[i] = Integer.parseInt(String.valueOf(nums[i].reverse()));<br>  		<br>  		<br>  	&#125;<br>  <br>  &#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="排序算法总结">排序算法总结</h4>
<ul>
<li><table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 17%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 12%" />
<col style="width: 11%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">[ ]</th>
<th style="text-align: center;">排序算法</th>
<th style="text-align: center;">平均时间复杂度</th>
<th style="text-align: center;">最好情况</th>
<th style="text-align: center;">最坏情况</th>
<th style="text-align: center;">空间复杂度</th>
<th style="text-align: center;">排序方式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>冒泡排序</strong></td>
<td style="text-align: center;">O(n^2)</td>
<td style="text-align: center;">O(n)</td>
<td style="text-align: center;">O(n^2)</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: center;">In-place</td>
<td style="text-align: center;">稳定</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>选择排序</strong></td>
<td style="text-align: center;">O(n^2)</td>
<td style="text-align: center;">O(n^2)</td>
<td style="text-align: center;">O(n^2)</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: center;">In-place</td>
<td style="text-align: center;">不稳定</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>插入排序</strong></td>
<td style="text-align: center;">O(n^2)</td>
<td style="text-align: center;">O(n)</td>
<td style="text-align: center;">O(n^2)</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: center;">In-place</td>
<td style="text-align: center;">稳定</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>希尔排序</strong></td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O(n * log^2(n))</td>
<td style="text-align: center;">O(n * log^2(n))</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: center;">In-place</td>
<td style="text-align: center;">不稳定</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>快速排序</strong></td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O（n^2）</td>
<td style="text-align: center;">O(log(n))</td>
<td style="text-align: center;">In-place</td>
<td style="text-align: center;">不稳定</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>合并排序</strong></td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O（n）</td>
<td style="text-align: center;">Out-place</td>
<td style="text-align: center;">稳定</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>堆排序</strong></td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O(n * log(n))</td>
<td style="text-align: center;">O(1）</td>
<td style="text-align: center;">In-pace</td>
<td style="text-align: center;">不稳定</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>基数排序</strong></td>
<td style="text-align: center;">O(n * k)</td>
<td style="text-align: center;">O(n * k)</td>
<td style="text-align: center;">O(n * k)</td>
<td style="text-align: center;">O(n + k)</td>
<td style="text-align: center;">Out-place</td>
<td style="text-align: center;">稳定</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>桶排序</strong></td>
<td style="text-align: center;">O(n + k)</td>
<td style="text-align: center;">O(n + k)</td>
<td style="text-align: center;">O(n^2)</td>
<td style="text-align: center;">O(n + k)</td>
<td style="text-align: center;">Out-place</td>
<td style="text-align: center;">稳定</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>计数排序</strong></td>
<td style="text-align: center;">O(n + k)</td>
<td style="text-align: center;">O(n + k)</td>
<td style="text-align: center;">O(n + k)</td>
<td style="text-align: center;">O(k)</td>
<td style="text-align: center;">Out-place</td>
<td style="text-align: center;">稳定</td>
</tr>
</tbody>
</table></li>
<li><p><label><input type="checkbox" />相关术语：</label></p>
<ul>
<li>稳定 / 不稳定</li>
<li>内排序 / 外排序：所有操作是否在内存中完成</li>
<li>时间复杂度/空间复杂度</li>
<li>In-place / Out-place：是否占用额外的空间</li>
</ul></li>
</ul>
<h3 id="查找算法">查找算法</h3>
<ul class="task-list">
<li><label><input type="checkbox" />顺序查找</label></li>
<li><label><input type="checkbox" checked="" />二分查找</label></li>
<li><label><input type="checkbox" checked="" />插值查找</label></li>
<li><label><input type="checkbox" checked="" />斐波那契查找</label></li>
<li><label><input
type="checkbox" /><strong>在以上所有的查找算法中只有顺序查找不要求数组有序，其余的算法均需要要求数列有序</strong></label></li>
</ul>
<h4 id="顺序查找">顺序查找</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />原理：懂得都懂</label></p></li>
<li><p><label><input type="checkbox" />```java package
SearchAlgorithm;</label></p>
<p>public class SeqSearch {</p>
<p>static public int search(int arr[],int key) { for(int i = 0;i &lt;
arr.length;i++) if(arr[i] == key)return i; return -1; }</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br><br><br><br><br>#### 二分查找<br><br>- [ ] 基本原理<br><br>  - 先决条件位数组必须是**有序数组，否则不能使用二分查找**<br>  - 分类：<br>    1. 递归式<br>    2. 迭代式<br>  - 注意点，left和right位置的元素是否可以取到<br><br>- [ ] ```java<br>  package SearchAlgorithm;<br>  <br>  public class BinarySearch &#123;<br>  	<br>  	<br>  	static public int searchIterator(int arr[],int key,int left,int right) &#123;<br>  		if(left &lt;= right) &#123;<br>  			while(left &lt;= right) &#123;<br>  				int mid = (left + right) / 2;<br>  				if(arr[mid] == key)return mid;<br>  				else if(arr[mid] &gt; key)right = mid - 1;<br>  				else left = mid + 1;<br>  			&#125;<br>  			return -1;<br>  		&#125;<br>  		else return -1;<br>  	&#125;<br>  	<br>  	<br>  	static public int searchRecursion(int arr[],int key,int left,int right) &#123;<br>  		<br>  		if(left &lt;= right) &#123;<br>  			int mid = (left + right) / 2;<br>  			if(arr[mid] == key)return mid;<br>  			else &#123;<br>  				if(arr[mid] &gt; key)return searchRecursion(arr, key, left, mid - 1);<br>  				else return searchRecursion(arr, key, mid + 1, right);<br>  			&#125;<br>  		&#125;<br>  		else return -1;<br>  	&#125;<br>  <br>  &#125;<br>  <br></code></pre></td></tr></table></figure></li>
<li><p><label><input
type="checkbox" />改进二分查找，查找所有的元素</label></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchAll</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> key,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,HashSet pos)</span> &#123;<br>		<span class="hljs-keyword">if</span>(left &lt;= right) &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>			<span class="hljs-keyword">if</span>(arr[mid] == key) &#123;<br>				pos.add(mid);<br>				searchAll(arr,key,left,mid - <span class="hljs-number">1</span>,pos);<br>				searchAll(arr,key,mid + <span class="hljs-number">1</span>,right,pos);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">if</span>(arr[mid] &gt; key)searchAll(arr, key, left, mid - <span class="hljs-number">1</span>,pos);<br>				<span class="hljs-keyword">else</span> searchAll(arr, key, mid + <span class="hljs-number">1</span>, right,pos);<br>			&#125;<br>		&#125;<br>		<br>		<br>	&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="插值查找">插值查找</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本原理：</label></p>
<ul>
<li>对于二分查找的改进版</li>
<li>也需要数组为<strong>有序数组</strong></li>
<li>即将<strong>数组补充为fabnacci数组</strong>，通过找到分割点fab[k -
1] +
1的位置，判断在key和该点的关系，从而确定接下来的k值和要找的部位</li>
</ul></li>
<li><p><label><input type="checkbox" />改进部位：</label></p>
<blockquote>
<p>对于二分查找：mid = low + 0.5 * (high -
low)【这样忽略了key值对于查找的启发】</p>
<p>插值查找更像是二分查找的启发式查找：</p>
<ul>
<li>mid = low + (key - arr[low]) / (arr[high] - arr[low]) * (high -
low)</li>
<li>从而体现了key值对于查找范围的启发</li>
</ul>
</blockquote></li>
<li><p><label><input type="checkbox" />注意点：</label></p>
<ul>
<li><strong>因为为key - arr[left]，所有需要保证key大于左值</strong></li>
<li><strong>又因为需要乘积因子小于等于1，所以key小于等于右值</strong></li>
</ul></li>
<li><p><label><input type="checkbox" />```java package
SearchAlgorithm;</label></p>
<p>public class InterpolationSearch {</p>
<p>static public int search(int arr[],int key,int left,int right) {
if(left &lt;= right &amp;&amp; key &gt;= arr[left] &amp;&amp; key &lt;=
arr[right]) { double coeffcient = (double)(key - arr[left]) /
(double)(arr[right] - arr[left]); int pos = left + (int)(coeffcient *
(right - left)); if(arr[pos] == key)return pos; else { if(arr[pos] &gt;
key)return search(arr, key, left, pos - 1); else return search(arr, key,
pos + 1, right); }</p>
<pre><code>  &#125;
  else return -1;</code></pre>
<p>}</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>- [ ] 与二分查找比较：<br><br>  - 对于数据量较大，关键字分布均匀使用插值查找效率要高于二分查找<br>  - 关键词分布不均匀的情况下可能不如二分查找<br><br><br><br>#### 斐波那契查找<br><br>- [ ] 基本原理：斐波那契查找，别名：黄金分割查找。<br><br>  - &gt; 补充小知识：<br>    &gt;<br>    &gt; 对于斐波那契序列，相邻的两个值逐渐接近黄金分割数0.618,可以通过斐波那契数列计算黄金分割的近似值<br><br>  - 斐波那契查找也为改变coefficient值，从而完成有序数列的查找<br><br>  - 斐波那契查找也需要数组是有序数组<br><br>  - &gt; **pos = low + fab[k - 1] - 1**<br><br>- [ ] ![](/img/picLib/fabs.png)<br><br>- [ ] ```java<br>  package SearchAlgorithm;<br>  <br>  import java.util.Arrays;<br>  <br>  public class FabonacciSearch &#123;<br>  	<br>  	<br>  	static public int maxSize = 30;<br>  	<br>  	static public int[] getFabonacci() &#123;<br>  		int arr[] = new int[maxSize];<br>  		arr[0] = 1;<br>  		arr[1] = 1;<br>  		for(int i = 2;i &lt; 30;i++)<br>  			arr[i] = arr[i - 1] + arr[i - 2];<br>  		return arr;<br>  	&#125;<br>  	<br>  	static public int search(int arr[],int key) &#123;<br>  		int left = 0;<br>  		int right = arr.length - 1;<br>  		int k = 0;<br>  		int fabHeap[] = getFabonacci();<br>  		<br>  		while(right &gt;= fabHeap[k] - 1)k++; //找到合适的k值<br>          <br>  		int temp[] = Arrays.copyOf(arr, fabHeap[k]);<br>  		<br>  		for(int i = right + 1;i &lt; temp.length;i++) // 使用arr[right]进行填充空白区域<br>  			temp[i] = arr[right];<br>  		<br>  		while(left &lt;= right) &#123;<br>  			int pos = left + fabHeap[k - 1] - 1;<br>  			if(temp[pos] &gt; key) &#123; //在前一段<br>  				right = pos - 1;<br>  				k--;<br>  			&#125;<br>  			else if(temp[pos] &lt; key) &#123; //在后一段<br>  				left = pos + 1;<br>  				k -= 2;<br>  			&#125;<br>  			else &#123;<br>  				if(pos &lt;= right)return pos; //在补充部位<br>  				else return right;<br>  			&#125;<br>  		&#125;<br>  		return -1;<br>  		<br>  	&#125;<br>  	<br>  	<br>  &#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="哈希表非冲突消解">哈希表【非冲突消解】</h3>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本概念：</label></p>
<ul>
<li>根据关键码值而直接进行访问的数据结构，通过把关键码值进行映射到表中的一个位置来访问，从而加快访问记录，映射函数叫做散列函数</li>
</ul></li>
<li><p><label><input type="checkbox" />注意：</label></p>
<ul>
<li>HashTable实际上是二维的结构，因此在创建链表数组对象后需要动态的创建数组的每一个对象</li>
<li>哈希表实质上是数据结构的组合，利用数组进行哈希值处理，在相同HashCode基础上，再通过其他数据结构存储相同HashCode的元素，从而加快了查找的效率</li>
<li>采用上述方法即不用再使用冲突消解策略，当HashCode相同时采用高效的数据结构进行存储，优点是增加了代码的适用性，但是Hash查找的效率不是O(1)了，而是存储数据结构的效率</li>
</ul></li>
</ul>
<h4 id="员工管理哈希">员工管理哈希</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> HashTable;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashQuestion</span> &#123;<br>	<br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-type">HashManage</span> <span class="hljs-variable">manage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashManage</span>(<span class="hljs-number">10</span>);<br>		manage.addEmp(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;111&quot;</span>));<br>		<span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> manage.searchByID(<span class="hljs-number">1</span>);<br>		System.out.println(e);<br>	&#125;<br>	<br>	<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;<br>	<span class="hljs-type">int</span> id;<br>	String name;<br>	<span class="hljs-type">boolean</span> sex;<br>	String address;<br>	<br>	<span class="hljs-type">Employee</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;;<br>	<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String name)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-built_in">this</span>.id = id;<br>		<span class="hljs-built_in">this</span>.name = name;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;id: &quot;</span> + id + <span class="hljs-string">&quot; name: &quot;</span> + name;<br>	&#125;<br>	<br>	<br>	<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashManage</span>&#123;<br>	EmpList hashTable[];<br>	<span class="hljs-type">int</span> size;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashManage</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		hashTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpList</span>[size];<br>		<span class="hljs-built_in">this</span>.size = size;<br>		<span class="hljs-comment">// 注意需要初始化每个位置的链表</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; hashTable.length;i++)<br>			hashTable[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpList</span>();<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashFunc</span><span class="hljs-params">(Employee e)</span> &#123;<br>		<span class="hljs-keyword">return</span> e.id % <span class="hljs-built_in">this</span>.size;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>		<span class="hljs-keyword">return</span> id % <span class="hljs-built_in">this</span>.size;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEmp</span><span class="hljs-params">(Employee e)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.hashFunc(e);<br>		hashTable[pos].add(e);	<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">searchByID</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.hashFunc(id);<br>		<span class="hljs-type">Employee</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> hashTable[pos].head;<br>		<span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">null</span>)<br>			<span class="hljs-keyword">if</span>(temp.id == id)<span class="hljs-keyword">return</span> temp;<br>			<span class="hljs-keyword">else</span> temp = temp.next;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		<br>	&#125;<br>	<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpList</span>&#123;<br>	<span class="hljs-type">Employee</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Employee e)</span> &#123;<br>		<span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)<br>			head = e;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-type">Employee</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>			<span class="hljs-keyword">while</span>(temp.next != <span class="hljs-literal">null</span>)temp = temp.next;<br>			temp.next = e;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-type">Employee</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>		<span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">null</span>) &#123;<br>			System.out.println(temp);<br>			temp = temp.next;<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="树">树</h3>
<h4 id="树结构基础部分">树结构基础部分</h4>
<blockquote>
<p><strong>此章所有代码均放在章节末BinaryTree中</strong></p>
</blockquote>
<h5 id="树的基本术语">树的基本术语</h5>
<ul class="task-list">
<li><p><label><input type="checkbox" />节点</label></p></li>
<li><p><label><input type="checkbox" />根节点</label></p></li>
<li><p><label><input type="checkbox" />父节点</label></p></li>
<li><p><label><input type="checkbox" />子节点</label></p></li>
<li><p><label><input type="checkbox" />叶子节点</label></p></li>
<li><p><label><input type="checkbox" />节点权值</label></p></li>
<li><p><label><input type="checkbox" />路径</label></p></li>
<li><p><label><input type="checkbox" />子树</label></p></li>
<li><p><label><input type="checkbox" />树的高度</label></p></li>
<li><p><label><input type="checkbox" />森林</label></p></li>
</ul>
<h5 id="数组链表树分析">数组，链表，树分析</h5>
<ul class="task-list">
<li><label><input type="checkbox" />数组结构：</label>
<ul>
<li>优点：
<ol type="1">
<li>通过下标访问元素，速度快</li>
<li>对于有序数组，可以通过有序查找算法提高查找效率</li>
</ol></li>
<li>缺点:
<ol type="1">
<li>检索某一个值或者插入值需要指针对整个数组的移动，效率低</li>
</ol></li>
</ul></li>
<li><label><input type="checkbox" />链表结构：</label>
<ul>
<li>优点：
<ol type="1">
<li>在一定程度上对数组的<strong>插入删除</strong>进行了优化</li>
</ol></li>
<li>缺点：
<ol type="1">
<li>检索效率依然很慢</li>
</ol></li>
</ul></li>
<li><label><input type="checkbox" />数结构：</label>
<ul>
<li>优点：
<ol type="1">
<li>能提高数据的检索效率</li>
<li>既能保证插入删除的效率，又能保证检索的效率</li>
</ol></li>
<li>缺点：
<ol type="1">
<li>需要占用更大的存储空间</li>
</ol></li>
</ul></li>
</ul>
<h4 id="二叉树">二叉树</h4>
<h5 id="基本概念">基本概念</h5>
<ul class="task-list">
<li><p><label><input
type="checkbox" />每个节点最多只能有两个子节点，且子节点分为左右子节点</label></p></li>
<li><p><label><input
type="checkbox" />若每层均满，则n层<strong>共有2^(n） -
1</strong>个节点，<strong>第n层有2^(n - 1)</strong>个</label></p></li>
<li><p><label><input
type="checkbox" />如果所有的叶子节点<strong>均在最后一层</strong>，则该二叉树称为<strong>满二叉树</strong></label></p></li>
<li><p><label><input type="checkbox" />完全二叉树：</label></p>
<ul>
<li><p>所有的叶子节点<strong>均在最后一层或者倒数第二层</strong></p></li>
<li><p>且<strong>最后一层的节点左连续，倒数第二层的节点右连续</strong></p>
<p>则称该二叉树为完全二叉树</p></li>
</ul>
<p><strong>【民间定义】:</strong> <strong>若一个树的深度为L,则从0~L -
1层位满层，最后一层可能但不为满层，但一定是左连续的</strong></p></li>
</ul>
<h5 id="二叉树的遍历">二叉树的遍历</h5>
<h6 id="前序遍历">前序遍历</h6>
<ul class="task-list">
<li><label><input type="checkbox" />基本概念：遍历顺序：根 -&gt; 左
-&gt; 右</label></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(Node node)</span> &#123;<br>		<span class="hljs-comment">// node -&gt; left -&gt; right</span><br>		<span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>			System.out.println(node);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			System.out.println(node); <br>			<span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)preorderTraversal(node.left);<br>			<span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)preorderTraversal(node.right);<br>		&#125;<br>	&#125;<br>	<br></code></pre></td></tr></table></figure>
<h6 id="中序遍历">中序遍历</h6>
<ul class="task-list">
<li><label><input type="checkbox" />基本概念：遍历顺序：左-&gt; 根 -&gt;
右</label></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(Node node)</span> &#123;<br>		<span class="hljs-comment">// left -&gt; node -&gt; right</span><br>		<span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>			System.out.println(node);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<br>			<span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)inorderTraversal(node.left);<br>			System.out.println(node);<br>			<span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)inorderTraversal(node.right);<br>		&#125;<br>		<br>	&#125;<br>	<br></code></pre></td></tr></table></figure>
<h6 id="后续遍历">后续遍历</h6>
<ul class="task-list">
<li><label><input type="checkbox" />基本概念：遍历顺序: 左 -&gt; 右
-&gt; 根</label></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subsequentTraversal</span><span class="hljs-params">(Node node)</span> &#123;<br>		<span class="hljs-comment">// left -&gt; right -&gt; node</span><br>		<span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>			System.out.println(node);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<br>			<span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)subsequentTraversal(node.left);<br>			<span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)subsequentTraversal(node.right);<br>			System.out.println(node);<br>		&#125;<br>		<br>	&#125;<br></code></pre></td></tr></table></figure>
<h5 id="顺序存储二叉树">顺序存储二叉树</h5>
<ul class="task-list">
<li><p><label><input
type="checkbox" />基本原理：遍历数组时可以以遍历二叉树的方式【前序，中序，后序】的方式进行遍历</label></p></li>
<li><p><label><input
type="checkbox" />顺序存储二叉树特点【n表示数组下标】：</label></p>
<ul>
<li>顺序存储二叉树一般只考虑完全二叉树</li>
<li>第n个元素的左子节点位2 * n + 1</li>
<li>第n个元素的右子节点位2 * n + 2</li>
<li>第n个元素的父节点位 Integer[（n - 1） / 2]</li>
</ul></li>
<li><p><label><input type="checkbox" />```java public void travelArr(int
arr[],int turn) { //数组的树形遍历【只支持完全二叉树】</label></p>
<pre><code>          CompTree tree = new CompTree(arr);
          switch(turn) &#123;
          case 1:tree.preorder(0);break;
          case 2:tree.inorder(0);break;
          case 3:tree.subsequent(0);break;

          &#125;
      &#125;

      class CompTree&#123;
          public CompTree(int arr[]) &#123;
              // TODO Auto-generated constructor stub
              this.arr = arr;
          &#125;
          int arr[];

          public void preorder(int index) &#123;
              System.out.println(arr[index]);
              int left = 2 * index + 1;
              int right = 2 * index + 2;
              if(left &lt; arr.length)preorder(left);
              if(right &lt; arr.length)preorder(right);
          &#125;

          public void inorder(int index) &#123;

              int left = 2 * index + 1;
              int right = 2 * index + 2;
              if(left &lt; arr.length)inorder(left);
              System.out.println(arr[index]);
              if(right &lt; arr.length)inorder(right);
          &#125;

          public void subsequent(int index) &#123;
              int left = 2 * index + 1;
              int right = 2 * index + 2;
              if(left &lt; arr.length)subsequent(left);
              if(right &lt; arr.length)subsequent(right);
              System.out.println(arr[index]);
          &#125;
      &#125;</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>- [ ] 应用场景：**堆排序**<br><br><br><br><br><br>##### 线索二叉树<br><br>- [ ] 基本介绍：<br><br>  - 由于在原本的树中，有些节点的**空指针无法使用**，即浪费了许多空间<br><br>  - 使用线索二叉树可以充分利用各个节点的左右指针，让各个节点指向自己的前后节点<br><br>  - 对于最初的二叉树，若有n个节点，则一定有**n + 1的空指针域**<br><br>    &gt; n个节点含有2 * n个指针，有n - 1个节点【即除去root】都有一个指针指向该节点。<br>    &gt;<br>    &gt; 所以，空节点个数 = (2 * n) - (n - 1) = n + 1<br><br>  - 利用空指针域指向某种遍历顺序下的前期和后继（**这种附加的指针称为线索**）<br><br>  - 根据线索的种类不同分为：前序线索二叉树，中序线索二叉树，后续线索二叉树<br>  <br>- [ ] 对于线索化后的二叉树：<br><br>  - 左指针可能指向左子树也可能指向前驱节点<br>  - 右指针可能指向右子树也可能指向后继节点<br>  - 所以需要额外设置一个变量用来表明其指针指向的是子树还是前/后驱节点<br><br>- [ ] 构造线索注意：<br><br>  - 对于每一个node，既是上一个节点的后继，又是下一个节点的前驱，因此，对于操作每一个节点是，将每一个node都当作中间节点来判断，且均需要考虑PreNode,和该节点的LeftNode，操作每一个节点时，都不考虑此次节点的right，因为右指针指向的是后继，递归的操作后继节点时，将该节点当作pre来对待即可<br><br>- [ ] 遍历线索二叉树注意：<br><br>  - 不可以使用原本的递归方法进行遍历【由于原本的空指针成为了线索，若递归遍历会造成死循环】<br>  - 使用线索化后，依然会有剩余的指针<br>    1. 对于前序线索化，会空出一个尾指针<br>    2. 对于中序线索化会空出一个头指针和一个尾指针<br>    3. 对于后续线索化会空出一个头指针<br>  - 空出的指针是遍历是结束的标志<br><br>- [ ] 这里只强调**前序线索化**和**中序线索化**【对于后续线索化太鸡儿麻烦，且需要额外的空间存父指针】<br><br>- [ ] ![](/img/picLib/preThreaded.png)<br><br>  ![Inthreaded](/img/picLib/Inthreaded.png)<br><br>- [ ] ```java<br>  	public boolean threaded = false;<br>  	<br>  	public void treeToThreaded(int turn) &#123;<br>  		this.threaded = true;<br>  		ThreadedBinTree binTree = new ThreadedBinTree();<br>  		switch(turn) &#123;<br>  		case 1:binTree.preThreadedTree(this.root);break;<br>  		case 2:binTree.inThreadTree(this.root);break;<br>  		case 3:binTree.subThreadTree(this.root);break;	<br>  		<br>  		&#125;<br>  		<br>  	&#125;<br>  	<br>  	<br>  	class ThreadedBinTree&#123;<br>  		<br>  		private Node pre = null;<br>  		<br>  		public void preThreadedTree(Node node) &#123;<br>  			if(node == null)return;<br>  			else &#123;<br>  				if(node.left == null) &#123;<br>  					node.left = pre;<br>  					node.lThread = true;<br>  				&#125;<br>  				if(pre != null &amp;&amp; pre.right == null) &#123;<br>  					pre.right = node;<br>  					pre.rThread = true;<br>  				&#125;<br>  				pre = node;<br>  				<br>  				<br>  				if(node.left != null &amp;&amp; !node.lThread)this.preThreadedTree(node.left);<br>  				if(node.right != null &amp;&amp; node.left != node.right)this.preThreadedTree(node.right);<br>  				<br>  			&#125;<br>  			<br>  		&#125;<br>  		<br>  		public void inThreadTree(Node node) &#123;<br>  			if(node == null)return;<br>  			else &#123;<br>  				if(node.left != null)this.inThreadTree(node.left);<br>  				<br>  				if(node.left == null) &#123;<br>  					node.lThread = true;<br>  					node.left = pre;<br>  				&#125;<br>  				<br>  				if(pre != null &amp;&amp; pre.right == null) &#123;<br>  					pre.right = node;<br>  					pre.rThread = true;<br>  				&#125;<br>  					<br>  				pre = node;<br>  				<br>  				if(node.right != null)this.inThreadTree(node.right);<br>  				<br>  				<br>  			&#125;<br>  		&#125;<br>  		<br>  		<br>  		public void preTraver(Node node) &#123;<br>  			while(node != null) &#123;<br>  				while(!node.lThread) &#123;<br>  					System.out.println(node);<br>  					node = node.left;<br>  				&#125;<br>  				System.out.println(node);<br>  				node = node.right;<br>  				while(node != null &amp;&amp; node.rThread) &#123;<br>  					System.out.println(node);<br>  					node = node.right;<br>  				&#125;<br>  				<br>  				<br>  			&#125;<br>  			<br>  		&#125;<br>  		<br>  		public void inTraversal(Node node) &#123;<br>  			while(node != null) &#123;<br>  				while(!node.lThread)node = node.left;<br>  				System.out.println(node);<br>  				while(node.rThread) &#123;<br>  					node = node.right;<br>  					System.out.println(node);<br>  				&#125;<br>  				node = node.right;<br>  			&#125;<br>  			<br>  		&#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="堆和堆排序">堆和堆排序</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本介绍：</label></p>
<ul>
<li><p>堆排序是一种排序算法，其最快，最坏，平均时间复杂度均为O（n *
logn）</p></li>
<li><p>堆排序也为不稳定排序</p></li>
<li><p>堆【<strong>前提条件是堆是一个完全二叉树</strong>】：</p>
<p>堆是具有以下性质的<strong>完全二叉树</strong>：</p>
<ol type="1">
<li>每个节点的值都大于或等于其左右子节点的值，称为大顶堆</li>
<li>每个节点的值都小于或等于其左右子节点的值，称为小顶对</li>
<li>对左右子节点的值没有数值上的要求</li>
</ol></li>
</ul></li>
<li><p><label><input type="checkbox" />堆排序思想和步骤：</label></p>
<ul>
<li>用数组模拟完全二叉树</li>
<li>将待排序序列构建成一个大顶堆，最大值即根节点</li>
<li>将其与末尾元素交换，此时末尾元素即最大值</li>
<li>然后将剩余的n - 1个元素构建成大顶堆</li>
<li>重复上述步骤，直到构建称有序序列</li>
</ul></li>
<li><p><label><input type="checkbox" />分类：</label></p>
<ul>
<li><strong>升序构建小顶堆</strong></li>
<li><strong>降序构建大顶堆</strong></li>
</ul></li>
<li><p><label><input type="checkbox" />操作注意：</label></p>
<ul>
<li>首先找到第一个非叶子节点即 <strong>pos = (arr.length - 1) /
2</strong></li>
<li>从第一个非叶子节点向前直到根节点【在数组中表示成从pos 到
0】依次取max(left,right,node.value)的最大值</li>
<li>遍历一遍得到当前数组的最大值，剔除（与尾元素交换）</li>
<li>直到数组的长度为0</li>
</ul></li>
<li><p><label><input type="checkbox" /><img
src="/img/picLib/heapSort.png" /></label></p></li>
<li><p><label><input
type="checkbox" />堆排序实现既可以使用<strong>递归</strong>也可以使用<strong>非递归</strong>方法【此处采用了非递归方法】</label></p></li>
<li><p><label><input type="checkbox" />```java package Tree;</label></p>
<p>import java.util.Arrays;</p>
<p>import org.junit.jupiter.api.Test;</p>
<p>public class HeapSort { <span class="citation"
data-cites="Test">@Test</span> public void test() { int arr[] =
{1,2,6,5,2,1,4,9,7,8}; Heap heap = new Heap(arr); heap.heapSort(true);
System.out.println(Arrays.toString(heap.sortArr)); }</p>
<p>}</p>
<p>class Heap{ public int arr[]; public int sortArr[]; static final int
maxNum = 65535;</p>
<p>public Heap(int arr[]) { // TODO Auto-generated constructor stub
this.arr = arr; this.sortArr = new int[arr.length]; }</p>
<p>public void swapSmall(int pos,int pos1,int pos2,int length) { int v =
arr[pos]; int v1 = this.maxNum; int v2 = this.maxNum; if(pos1 &lt;=
length)v1 = arr[pos1]; if(pos2 &lt;= length)v2 = arr[pos2];</p>
<pre><code>  if(v1 &lt; v2 &amp;&amp; v1 &lt; v) &#123;
      int temp = arr[pos];
      arr[pos] = arr[pos1];
      arr[pos1] = temp;
  &#125;
  else if(v2 &lt; v1 &amp;&amp; v2 &lt; v)&#123;
      int temp = arr[pos];
      arr[pos] = arr[pos2];
      arr[pos2] = temp;
  &#125;</code></pre>
<p>}</p>
<p>public void swapBig(int pos,int pos1,int pos2,int length) { int v =
arr[pos]; int v1 = 0; int v2 = 0; if(pos1 &lt;= length)v1 = arr[pos1];
if(pos2 &lt;= length)v2 = arr[pos2];</p>
<pre><code>  if(v1 &gt; v2 &amp;&amp; v1 &gt; v) &#123;
      int temp = arr[pos];
      arr[pos] = arr[pos1];
      arr[pos1] = temp;
  &#125;
  else if(v2 &gt; v1 &amp;&amp; v2 &gt; v)&#123;
      int temp = arr[pos];
      arr[pos] = arr[pos2];
      arr[pos2] = temp;
  &#125;</code></pre>
<p>}</p>
<p>public void heapSort(boolean turn) { if(turn) { int length =
arr.length - 1; int index = 0; while(length &gt;= 0) { int point =
(length - 1)/2; for(int i = point;i &gt;= 0;i--) this.swapSmall(i,2 * i
+ 1,2 * i + 2,length);</p>
<pre><code>          sortArr[index++] = arr[0];
          arr[0] = arr[length];
          length--;
      &#125;
  &#125;
  else &#123;
      int length = arr.length - 1;
      int index = 0;
      while(length &gt;= 0) &#123;
          int point = (length / 2) - 1;
          for(int i = point;i &gt;= 0;i--)
              this.swapBig(i,2 * i + 1,2 * i + 2,length);

          sortArr[index++] = arr[0];
          arr[0] = arr[length];
          length--;
      &#125;
  &#125;

  this.arr = this.sortArr;</code></pre>
<p>}</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br><br><br><br>##### 通过堆排序实现优先队列<br><br>- [ ] 思路：Compareable接口 + 堆排序【虽然java已经有现成的TreeMap进行优先级的排序且底层的RBTree效率更高，写优先队列只是跟好的理解堆排序的思想】<br>  - add进行建堆，将node插入完全二叉树的可插入位置，即数组的最后一个位置<br>  - add后进行动态的维护堆<br>  - pop将最后一个元素调到第一个并将数组长度-1，即arr[0] = arr[length--],再进行堆得的维护<br><br>- [ ] ```java<br>  package Tree;<br>  <br>  import java.lang.reflect.Array;<br>  import java.util.Arrays;<br>  import java.util.TreeMap;<br>  <br>  public class PriorityQueue&lt;E&gt; &#123;<br>  	private E arr[];<br>  	private Class cls;<br>  	<br>  	private int length;<br>  	private int capicity;<br>  	private double coffecient;<br>  	<br>  	<br>  	public PriorityQueue(Class clazz) &#123;<br>  		// TODO Auto-generated constructor stub<br>  		this.capicity = 16;<br>  		this.coffecient = 0.8;<br>  		this.length = 0;<br>  		this.cls = clazz;<br>  		<br>  		arr = (E[])Array.newInstance(clazz, 16);<br>  		<br>  	&#125;<br>  	<br>  	@Override<br>  	public String toString() &#123;<br>  		// TODO Auto-generated method stub<br>  		String str = &quot;&quot;;<br>  		for(int i = 0;i &lt; this.length;i++)<br>  			if(i == 0)str += arr[i];<br>  			else str += &quot;,&quot; + arr[i];<br>  		return &quot;[&quot; + str + &quot;]&quot;;<br>  	&#125;<br>  	<br>  	private void heapSort() &#123;<br>  		Heap heap = new Heap(arr);<br>  		this.arr = heap.adjust();<br>  	&#125;<br>  	<br>  	public void add(E e) &#123;<br>  		if(this.length &gt;= (this.capicity * this.coffecient)) &#123;<br>  			Arrays.copyOf(this.arr, this.capicity * 2);<br>  			this.capicity *= 2;<br>  		&#125;<br>  		<br>  		arr[this.length++] = e;<br>  		this.heapSort();<br>  	&#125;<br>  	<br>  	public E top() &#123;<br>  		if(this.length != 0)return arr[0];<br>  		return null;<br>  	&#125;<br>  	<br>  	<br>  	public int size() &#123;<br>  		return this.length;<br>  	&#125;<br>  	<br>  	public boolean isEmpty() &#123;<br>  		if(this.length == 0)return true;<br>  		else return false;<br>  	&#125;<br>  	<br>  	public E pop() &#123;<br>  		E e = null;<br>  		if(this.length != 0)e = arr[0];<br>  		else return null;<br>  		<br>  		arr[0] = arr[this.length - 1];<br>  		this.length--;<br>  		this.heapSort();<br>  		<br>  		return e;<br>  		<br>  		<br>  	&#125;<br>  	<br>  	private class Heap&#123;<br>  		private E heapArr[];<br>  		public Heap(E arr[]) &#123;<br>  			// TODO Auto-generated constructor stub<br>  			this.heapArr = (E[])Array.newInstance(cls, arr.length);<br>  		&#125;<br>  		<br>  		<br>  		public void swap(int pos,int pos1,int pos2,int len) &#123;<br>  		<br>  			Comparable node = (Comparable) arr[pos];<br>  			Comparable left = null;<br>  			Comparable right = null;<br>  			if(pos1 &lt;= len)left = (Comparable) arr[pos1];<br>  			if(pos2 &lt;= len)right = (Comparable) arr[pos2];<br>  			if(right != null) &#123;    <br>  				if(left.compareTo(right) &lt;= 0 &amp;&amp; left.compareTo(node) &lt;= 0 &amp;&amp; !arr[0].equals(left)) &#123;<br>  					E temp = arr[pos];<br>  					arr[pos] = arr[pos1];<br>  					arr[pos1] = temp;<br>  					return;<br>  				&#125;<br>  				if(right.compareTo(left) &lt;= 0 &amp;&amp; right.compareTo(node) &lt;= 0 &amp;&amp; !arr[0].equals(right)) &#123;<br>  					<br>  					E temp = arr[pos];<br>  					arr[pos] = arr[pos2];<br>  					arr[pos2] = temp;<br>  				&#125;<br>  			&#125;<br>  			else if(left != null &amp;&amp; left.compareTo(node) &lt; 0 &amp;&amp; !arr[0].equals(left)) &#123;<br>  				<br>  				E temp = arr[pos];<br>  				arr[pos] = arr[pos1];<br>  				arr[pos1] = temp;<br>  			&#125;<br>  			<br>  		<br>  			<br>  		&#125;<br>  		<br>  		public E[] adjust() &#123;<br>  			int len = length - 1;<br>  			int index = 0;<br>  			while(len &gt;= 0) &#123;<br>  				int point = (len - 1) / 2;<br>  				for(int i = point;i &gt;= 0;i--) <br>  					swap(i,i * 2 + 1,i * 2 + 2,len);<br>  				this.heapArr[index++] = arr[0];<br>  				arr[0] = arr[len];<br>  				len--;<br>  			&#125;<br>  			return this.heapArr;<br>  		&#125;<br>  		<br>  	&#125;<br>  	<br>  	<br>  <br>  &#125;<br>  <br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="哈夫曼树">哈夫曼树</h4>
<h5 id="基本概念-1">基本概念</h5>
<ul class="task-list">
<li><p><label><input type="checkbox" />HuffmanTree:</label></p>
<ul>
<li>给定n个值为n个叶子的权值，构造一棵二叉树，若二叉树的<strong>带权路径权值【wpl】</strong>为最小,则称为最优二叉树，即哈夫曼树</li>
<li>即使得生成的树权值较大的离root较劲，小的离得较远</li>
</ul></li>
<li><p><label><input type="checkbox" />相关概念</label></p>
<ul>
<li>路径和路径长度：从根节点到达其子节点的通路称为路径，通路的个数为路径长度，从root到达叶节点的长度为L
- 1</li>
<li><strong>节点</strong>的带权路径长度：<strong>路径 * 权值 =
WPL</strong></li>
<li><strong>树</strong>的带权路径长度：所有节点的带权路径长度之和即<strong>Sum(WPLi)
【i = 1,2,...n】</strong></li>
</ul></li>
<li><p><label><input type="checkbox" />```java class HuffmanTree{ public
HuffmanNode root = null; public ArrayList<HuffmanNode> list = new
ArrayList&lt;&gt;();</label></p>
<p>public HuffmanTree(int arr[]) { // TODO Auto-generated constructor
stub for(Integer w : arr) list.add(new HuffmanNode(w));
Collections.sort(list); this.constrHuffman(); }</p>
<p>public void preTravel(HuffmanNode node) {</p>
<pre><code>  System.out.println(node);
  if(node.left != null)this.preTravel(node.left);
  if(node.right != null)this.preTravel(node.right);</code></pre>
<p>}</p>
<p>public void constrHuffman() { while(!list.isEmpty()) { HuffmanNode
node1 = list.get(0); list.remove(0); HuffmanNode node2 = null;
if(!list.isEmpty()) { node2 = list.get(0); list.remove(0); } if(node2 ==
null) { list.add(node1); break; }</p>
<pre><code>      HuffmanNode node = new HuffmanNode(node1.weight + node2.weight);
      node.left = node1;
      node.right = node2;
      list.add(node);
      Collections.sort(list);

  &#125;

  this.root = list.get(0);</code></pre>
<p>}</p>
<p>} class HuffmanNode implements Comparable{ int weight; public
HuffmanNode left; public HuffmanNode right;</p>
<p>public HuffmanNode(int weight) { // TODO Auto-generated constructor
stub this.weight = weight; }</p>
<p><span class="citation" data-cites="Override">@Override</span> public
int compareTo(Object o) { // TODO Auto-generated method stub HuffmanNode
node = (HuffmanNode)o; if(this.weight &lt; node.weight)return -1; else
if(this.weight &gt; node.weight)return 1; else return 0; }</p>
<p><span class="citation" data-cites="Override">@Override</span> public
int hashCode() { final int prime = 31; int result = 1; result = prime *
result + weight; return result; }</p>
<p><span class="citation" data-cites="Override">@Override</span> public
boolean equals(Object obj) { if (this == obj) return true; if (obj ==
null) return false; if (getClass() != obj.getClass()) return false;
HuffmanNode other = (HuffmanNode) obj; if (weight != other.weight)
return false; return true; }</p>
<p><span class="citation" data-cites="Override">@Override</span> public
String toString() { // TODO Auto-generated method stub return weight +
""; }</p>
<p>} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>##### HuffmanCode（赫夫曼编码）<br><br>- [ ] 哈夫曼编码广泛用于**数据的压缩**，一般数据的压缩程度可以达到20% ~ 90%<br>- [ ] 哈夫曼编码是可变字长编码的一种（VLC）<br>- [ ] 按照压缩的原理：在传输过程中，出现次数多的使用较长的编码，出现次数少的，使用较短长度的编码<br>- [ ] **哈夫曼编码遵循前缀码原则，即任何一个元素的编码都不会为其他元素编码的前缀，保证了编码无二义性**<br>- [ ] 不同操作建立的哈夫曼树可能不同但是平均权值是一定相同的<br><br>###### 赫夫曼压缩<br><br>- [ ] 利用Huffman编码并持久化存储<br><br>- [ ] ```java<br>  	<br>  	private byte[] getByteStream(String text) &#123;<br>  		String coded = this.text2Code(text);<br>  		<br>  		int len = 0;<br>  		if(coded.length() % 8 == 0)len = coded.length() / 8;<br>  		else len = (coded.length() / 8) + 1;<br>  		<br>  		byte bytes[] = new byte[len];<br>  		<br>  		int index = 0;<br>  		for(int i = 0;i &lt; coded.length();i += 8) &#123;<br>  			String strByte = null;<br>  			if(i + 8 &lt; coded.length())strByte = coded.substring(i,i + 8);<br>  			else strByte = coded.substring(i);<br>  			bytes[index++] = (byte)Integer.parseInt(strByte,2);<br>  		&#125;<br>  		<br>  		return bytes;<br>  	&#125;<br>  	<br>  	<br>  	public void save(String path,byte[] bytes) &#123;<br>  		FileOutputStream fos = null;<br>  		BufferedOutputStream bfos = null;<br>  		<br>  		try &#123;<br>  			fos = new FileOutputStream(path);<br>  			bfos = new BufferedOutputStream(fos);<br>  			try &#123;<br>  				bfos.write(bytes);<br>  				bfos.flush();<br>  			&#125; catch (IOException e) &#123;<br>  				// TODO Auto-generated catch block<br>  				e.printStackTrace();<br>  			&#125;<br>  			<br>  			<br>  		&#125; catch (FileNotFoundException e) &#123;<br>  			// TODO Auto-generated catch block<br>  			e.printStackTrace();<br>  		&#125;finally &#123;<br>  			try &#123;<br>  				fos.close();<br>  				bfos.close();<br>  			&#125; catch (IOException e) &#123;<br>  				// TODO Auto-generated catch block<br>  				e.printStackTrace();<br>  			&#125;<br>  		&#125;<br>  		<br>  	&#125;<br>  	<br>  	public void zip(String text,String path) &#123;<br>  		byte bytes[] = this.getByteStream(text);<br>  		this.save(path, bytes);<br>  		System.out.println(&quot;zip sucessfully!&quot;);<br>  		<br>  	&#125;<br></code></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="赫夫曼解压">赫夫曼解压</h6>
<ul class="task-list">
<li><p><label><input
type="checkbox" />在解压时需要进行<strong>补位</strong>，不能直接对字节类型进行截取【正数位数需要补位】</label></p></li>
<li><p><label><input type="checkbox" />```java public String
decoded(String path) throws IOException { String coded =
this.unZip(path); return this.code2Text(coded);</label></p>
<p>}</p>
<p>private int getFileSize(String path) { File file = new File(path);
if(file.exists())return (int) file.length(); else return -1; }</p>
<p>private String unZip(String path) throws IOException {
FileInputStream fis = null; BufferedInputStream bfis = null; String
coded = "";</p>
<pre><code>  int fileSize  =this.getFileSize(path);
  byte[] bytes = new byte[fileSize];

  try &#123;
      fis = new FileInputStream(path);
      bfis = new BufferedInputStream(fis);
      int len = 0;
      while((len = bfis.read(bytes)) != -1);

  &#125; catch (FileNotFoundException e) &#123;
      // TODO Auto-generated catch block
      e.printStackTrace();
  &#125;finally &#123;
      fis.close();
      bfis.close();
  &#125;


  for(int i = 0;i &lt; bytes.length;i++) &#123;
      int temp = bytes[i];
      if(i != bytes.length - 1) &#123;
          temp |= 256;
          String str = Integer.toBinaryString(temp);
          coded += str.substring(str.length() - 8); // 由于获得是补码因此不可以直接使用str，需要截取后8位
      &#125;
      else &#123;
          String str = Integer.toBinaryString(temp); // 最后一个Byte可能不满一个字节因此不需要进行补位
          coded += str;
      &#125;
  &#125;


  return coded;</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>######  赫夫曼文件压缩与解压<br><br>- [ ] 基本原理：<br><br>  - 通过对文件的二进制文件读取，将二进制的的整数型作为关键词进行哈夫曼编码，将编码后的文件和解码树一并存放<br>  - 读取时先读取编码文件，再读取解码树<br><br>- [ ] ```java<br>  package Tree.Huffman;<br>  <br>  import java.io.FileInputStream;<br>  import java.io.FileOutputStream;<br>  import java.io.IOException;<br>  import java.io.ObjectInputStream;<br>  import java.io.ObjectOutputStream;<br>  import java.util.ArrayList;<br>  import java.util.HashMap;<br>  <br>  import Tree.PriorityQueue;<br>  <br>  public class HuffmanCoder&#123;<br>  	<br>  	private HuffmanTree huffTree = null;<br>  	public HashMap&lt;Byte,String&gt; codeMap = new HashMap&lt;Byte, String&gt;();// key -&gt; 源码 value -&gt; huffCode<br>  	<br>  	private ArrayList&lt;HuffmanNode&gt; nodeList = new ArrayList();<br>  	<br>  	public HuffmanCoder() &#123;<br>  		// TODO Auto-generated constructor stub<br>  	&#125;<br>  	<br>  	<br>  	<br>  	private PriorityQueue&lt;HuffmanNode&gt; getHuffmanQueue(byte[] sCodes) &#123; // 通过对源文件的编码获得新的编码<br>  		PriorityQueue&lt;HuffmanNode&gt; queue = new PriorityQueue&lt;HuffmanNode&gt;(HuffmanNode.class);<br>  		HashMap&lt;Byte,Integer&gt; cntMap = new HashMap(); <br>  		<br>  		for(Byte code : sCodes) &#123;<br>  			if(cntMap.containsKey(code)) &#123;<br>  				int cnt = cntMap.get(code);<br>  				cntMap.put(code, cnt++);<br>  			&#125;<br>  			else cntMap.put(code, 1);<br>  		&#125;<br>  		<br>  		<br>  		for(Byte b : cntMap.keySet()) &#123;<br>  			int cnt = cntMap.get(b);<br>  			HuffmanNode node = new HuffmanNode(String.valueOf((int)b));<br>  			queue.add(node);<br>  		&#125;<br>  		<br>  		return queue;<br>  		<br>  		<br>  	&#125;<br>  	<br>  	<br>  	private byte[] restrore(String code) &#123;<br>  		HuffmanNode node = this.huffTree.root;<br>  		String reCode = &quot;&quot;;<br>  		<br>  		for (int i = 0; i &lt; code.length(); i++) &#123;<br>  			String c = code.charAt(i) + &quot;&quot;;<br>  			if(c.equals(&quot;0&quot;))node = node.left;<br>  			else node = node.right;<br>  			if(node.left == null &amp;&amp; node.right == null) &#123;<br>  				reCode += node.data;<br>  				node = this.huffTree.root;<br>  			&#125;<br>  		&#125;<br>  		<br>  		int len = (reCode.length() + 7) /  8; <br>  		byte[] bytes = new byte[len];<br>  		int index = 0;<br>  		for(int i = 0;i &lt; reCode.length();i++) &#123;<br>  			if(i != reCode.length() - 1) &#123;<br>  				String str = reCode.substring(i,i + 8);<br>  				bytes[index++] = (byte)Integer.parseInt(str,2);<br>  			&#125;<br>  			else &#123;<br>  				String str = reCode;<br>  				bytes[index++] = (byte)Integer.parseInt(str,2);<br>  			&#125;<br>  		&#125;<br>  		return bytes;<br>  		<br>  	&#125;<br>  	<br>  	private byte[] primaryCode(byte[] bytes) &#123;<br>  		String code = &quot;&quot;;<br>  		for(int i = 0;i &lt; bytes.length;i++) &#123;<br>  			int b = bytes[i]; //由于此步骤中b自动忽略了首部的0，因此需要在后需要的步骤中进行对0的补充<br>  			if(i != bytes.length - 1) &#123;<br>  				b |= 256; // 对0进行补位<br>  				String str = Integer.toBinaryString(b);<br>  				code += str.substring(str.length() - 8);<br>  				<br>  			&#125;<br>  			else &#123;<br>  				String str = Integer.toBinaryString(b);<br>  				code += str;<br>  				<br>  			&#125;<br>  		&#125;<br>  		return this.restrore(code);<br>  		<br>  	&#125;<br>  	<br>  	<br>  	<br>  	<br>  	public void decoding(String srcFile,String dstFile) &#123;<br>  		<br>  		FileInputStream fis = null;<br>  		ObjectInputStream ois = null;<br>  		FileOutputStream fos = null;<br>  		<br>  		try &#123;<br>  			fis = new FileInputStream(srcFile);<br>  			ois = new ObjectInputStream(fis);<br>  			byte[] bytes = (byte[]) ois.readObject();<br>  			HuffmanTree tree = (HuffmanTree) ois.readObject();<br>  			this.huffTree = tree;<br>  			byte[] priBytes = this.primaryCode(bytes);<br>  			fos.write(priBytes);<br>  			<br>  		&#125; catch (ClassNotFoundException | IOException e) &#123;<br>  			// TODO Auto-generated catch block<br>  			e.printStackTrace();<br>  		&#125;finally &#123;<br>  			try &#123;<br>  				fis.close();<br>  				ois.close();<br>  				fos.close();<br>  			&#125; catch (IOException e) &#123;<br>  				// TODO Auto-generated catch block<br>  				e.printStackTrace();<br>  			&#125;<br>  		&#125;<br>  		<br>  		<br>  		<br>  	&#125;<br>  	<br>  	<br>  	public void encoding(HuffmanNode node,String bit) &#123;<br>  		if(node.left == null &amp;&amp; node.right == null) &#123;<br>  			Byte code = (byte)Integer.parseInt(node.data);<br>  			codeMap.put(code, bit);<br>  		&#125;<br>  		else &#123;<br>  			if(node.left != null)this.encoding(node.left, bit + &quot;0&quot;);<br>  			if(node.right != null)this.encoding(node.right, bit + &quot;1&quot;);<br>  		&#125;<br>  	&#125;<br>  	<br>  	public byte[] source2Code(byte[] bytes) &#123;<br>  		String huffStr = &quot;&quot;; // 编码后的数组<br>  		for(Byte b : bytes) <br>  			huffStr += codeMap.get(b);<br>  		<br>  		int len = (huffStr.length() + 7) / 8;<br>  		byte[] codedBytes = new byte[len];<br>  		int index = 0;<br>  	<br>  		<br>  		<br>  		for(int i = 0;i &lt; huffStr.length();i += 8) &#123;<br>  			<br>  			if(i + 8 &lt; huffStr.length())<br>  				codedBytes[index++] = (byte)Integer.parseInt(huffStr.substring(i,i + 8),2);<br>  			else codedBytes[index++] = (byte)Integer.parseInt(huffStr.substring(i),2);<br>  		&#125;<br>  		<br>  		<br>  		return codedBytes;<br>  		<br>  		<br>  		<br>  		<br>  	&#125;<br>  	<br>  	public byte[] getHuffmanCodes(byte[] bytes) &#123;<br>  		<br>  		PriorityQueue&lt;HuffmanNode&gt; queue = this.getHuffmanQueue(bytes);<br>  		this.huffTree = new HuffmanTree();<br>  		this.huffTree.constrHuffman(queue);<br>  		<br>  		if(this.huffTree.root.left != null)this.encoding(this.huffTree.root.left, &quot;0&quot;);<br>  		if(this.huffTree.root.right != null)this.encoding(this.huffTree.root.right, &quot;1&quot;);<br>  		<br>  		return this.source2Code(bytes);<br>  		<br>  	&#125;<br>  	<br>  	<br>  	public void zipFile(String srcFile,String dstFile) &#123;<br>  		<br>  		FileInputStream fis = null;<br>  		FileOutputStream fos = null;<br>  		ObjectOutputStream oos = null;<br>  		<br>  		<br>  		try &#123;<br>  			fis = new FileInputStream(srcFile);<br>  			byte[] bytes = new byte[fis.available()];<br>  			fis.read(bytes);<br>  			byte[] huffmanCodes = this.getHuffmanCodes(bytes);<br>  			fos = new FileOutputStream(dstFile);<br>  			<br>  			oos = new ObjectOutputStream(fos);<br>  			oos.writeObject(huffmanCodes);<br>  			oos.writeObject(this.huffTree);<br>  			<br>  		&#125; catch (IOException e) &#123;<br>  			// TODO Auto-generated catch block<br>  			e.printStackTrace();<br>  		&#125;finally &#123;<br>  			try &#123;<br>  				fis.close();<br>  				fos.close();<br>  				oos.close();<br>  			&#125; catch (IOException e) &#123;<br>  				// TODO Auto-generated catch block<br>  				e.printStackTrace();<br>  			&#125;<br>  		&#125;<br>  		<br>  		<br>  		<br>  	&#125;<br>  	<br>  	<br>  	<br>  	<br>  	<br>  	<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="二叉排列树二叉搜索树">二叉排列树【二叉搜索树】</h4>
<h5 id="基本概念-2">基本概念</h5>
<ul class="task-list">
<li><label><input
type="checkbox" />二叉排序树要求左子树值小于当前的节点，右子树的值大于当前的节点</label></li>
<li><label><input type="checkbox" />由于二叉排列树的特点：即左&lt; 中
&lt;
右，因此通过<strong>中序遍历</strong>可以得到有序的从小到大的序列</label></li>
<li><label><input type="checkbox" />排列数最基本特点：</label>
<ul>
<li>最小值一定在最左边</li>
<li>最大值一定在最右边</li>
</ul></li>
</ul>
<h5 id="二叉排列树的创建和中序遍历">二叉排列树的创建和中序遍历</h5>
<ul class="task-list">
<li><p><label><input type="checkbox" />```java private void
insertNode(BinaryNode node,BinaryNode temp) { if(temp.compareTo(node)
&gt;= 0) { if(temp.left != null) this.insertNode(node, this.root.left);
else temp.left = node; } else { if(temp.right != null)
this.insertNode(node, this.root.right); else temp.right = node; }
}</label></p>
<p>public void insert(E data) { BinaryNode node = new BinaryNode(data);
if(this.root == null) { root = new BinaryNode<E>(data); return; } else {
if(this.root.compareTo(node) &gt;= 0) { if(this.root.left != null)
this.insertNode(node, this.root.left); else this.root.left = node;
return; } else { if(this.root.right != null) this.insertNode(node,
this.root.right); else this.root.right = node; return; } }</p>
<p>}</p>
<p>private void inOrderTra(BinaryNode<E> node) { if(node.left == null
&amp;&amp; node.right == null) { System.out.println(node); return; }
else { if(node.left != null)this.inOrderTra(node.left);
System.out.println(node); if(node.right !=
null)this.inOrderTra(node.right); } }</p>
<p>public void traversal() { this.inOrderTra(this.root); }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br><br><br>##### 二叉排列树的删除<br><br>- [ ] 对于二叉排列树的删除：<br><br>  - 若删除的是叶子节点：直接通过Parent节点进行删除<br><br>  - 若删除的节点仅有左节点或右节点：则让子节点代替当前节点<br><br>  - 若删除的节点左右节点均存在：<br><br>    1. 找到左子树最大的<br>    2. 或者找到右子树最小的<br><br>    使用找到的节点代替当前节点<br><br>- [ ] ```java<br>  public void deleteNode(BinaryNode&lt;E&gt; pre,BinaryNode&lt;E&gt; node,int type) &#123;<br>  		int pos = 0;<br>  		if(node == pre.left)pos = 1;<br>  		else pos = -1;<br>  		<br>  		switch(type) &#123;<br>  		case 0:&#123;<br>  			if(pos == 1)pre.left = null;<br>  			else pre.right = null;<br>  		&#125;;break;<br>  		case 1:&#123;<br>  			if(pos == 1) <br>  				pre.left = node.right;<br>  			else pre.right = node.right;<br>  			<br>  		&#125;;break;<br>  		case 2:&#123;<br>  			if(pos == 1)<br>  				pre.left = node.left;<br>  			else pre.right = node.left;<br>  			<br>  		&#125;;break;<br>  		case 3:&#123;<br>  			BinaryNode&lt;E&gt; temp = node.left;<br>  			BinaryNode&lt;E&gt; tempPre = node;<br>  			while(temp.right != null) &#123;<br>  				tempPre = temp;<br>  				temp = temp.right;<br>  			&#125;<br>  			node.data = temp.data;<br>  			tempPre.right = null;<br>  		&#125;<br>  			<br>  		<br>  		&#125;<br>  	&#125;<br>  	<br>  	private int deleteType(BinaryNode&lt;E&gt; node) &#123;<br>  		if(node.left != null &amp;&amp; node.right != null)return 3;<br>  		else if(node.left != null &amp;&amp; node.right == null)return 2;<br>  		else if(node.right != null &amp;&amp; node.left == null)return 1;<br>  		else return 0;<br>  		<br>  	&#125;<br>  	public void delete(E data) &#123;<br>  		if(this.root == null)return;<br>  		else &#123;<br>  			if(this.root.data.equals(data))&#123;<br>  				if(this.root.left != null) &#123;<br>  					BinaryNode&lt;E&gt;  node = this.root.left;<br>  					while(node.right != null)node = node.right;<br>  					BinaryNode&lt;E&gt; reNode = this.root.left;<br>  					while(reNode.right != null &amp;&amp; reNode.right != node)<br>  						reNode = reNode.right;<br>  					this.root = node;<br>  					reNode.right = null;<br>  				&#125;<br>  				else if(this.root.right != null)&#123;<br>  					BinaryNode&lt;E&gt;  node = this.root.right;<br>  					while(node.left != null)node = node.left;<br>  					BinaryNode&lt;E&gt; reNode = this.root.right;<br>  					while(reNode.left != null &amp;&amp; reNode.left != node)<br>  						reNode = reNode.left;<br>  					this.root = node;<br>  					reNode.left = null;<br>  				&#125;<br>  				else this.root = null;<br>  			&#125;<br>  			else &#123;		<br>  				BinaryNode&lt;E&gt; temp = null;<br>  				BinaryNode&lt;E&gt; pre = this.root;<br>  				BinaryNode&lt;E&gt; node = new BinaryNode&lt;E&gt;(data);<br>  				int comp = pre.compareTo(node);<br>  				if(comp &gt; 0)temp = pre.left;<br>  				else temp = pre.right;<br>  				while(temp != null) &#123;<br>  					comp = temp.compareTo(node);<br>  					if(comp &gt; 0) &#123;<br>  						pre = temp;<br>  						temp = temp.left;<br>  					&#125;<br>  					else if(comp &lt; 0) &#123;<br>  						pre = temp;<br>  						temp = temp.right;<br>  					&#125;<br>  					else &#123;<br>  						this.deleteNode(pre, temp, this.deleteType(temp));<br>  						return;<br>  					&#125;<br>  				&#125;<br>  				System.out.println(&quot;not find&quot;);<br>  			&#125;<br>  		&#125;<br>  	&#125;<br>  	<br></code></pre></td></tr></table></figure></li>
<li><p><label><input
type="checkbox" />基本删除思路很简单，但是需要注意对于root的处理，因为root没有preNode，因此对于root需要单独判断</label></p></li>
</ul>
<h4 id="二叉平衡树">二叉平衡树</h4>
<h5 id="基本概念-3">基本概念</h5>
<ul class="task-list">
<li><p><label><input
type="checkbox" />对于一般的二叉排序树，如果插入时是有序的数列则会长成</label></p>
<p><img src="/img/picLib/bstturn.png" /></p></li>
</ul>
<p>​
即生成一个链表形式，而不是树的形式，即树退化成了链表【对于插入和删除没有影响，但是查询速度为链表的查询速度】</p>
<ul class="task-list">
<li><label><input type="checkbox" />AVL特点：</label>
<ul>
<li>平衡二叉树树为空树，或者左右两个子树的高度差不超过1</li>
<li>平衡二叉树左右子树也均为平衡二叉树</li>
</ul></li>
<li><label><input type="checkbox" />平衡二叉树的常用实现方法：</label>
<ul>
<li>红黑树（RBTree）</li>
<li>AVL</li>
<li>替罪羊树</li>
<li>Treap</li>
<li>伸展树</li>
</ul></li>
<li><label><input type="checkbox" />旋转概念：</label>
<ul>
<li>左旋右长</li>
<li>右旋左长</li>
</ul></li>
</ul>
<h5 id="avl左旋转">AVL左旋转</h5>
<ul class="task-list">
<li><p><label><input
type="checkbox" />若插入右子树使得平衡二叉树失去平衡则需要进行左旋转</label></p></li>
<li><p><label><input type="checkbox" />基本步骤：</label></p>
<ul>
<li>创建一个新的节点（newNode），值等于根节点(root)的值</li>
<li>新节点（newNode）的左子树指向根节点(root)的左子树</li>
<li>新节点（newNode）的右子树指向根节点(root)右子树的左子树</li>
<li>根节点(root)的值替换为根节点(root)右子树的值</li>
<li>根节点(root)的右子树指向根节点(root)右子树的右子树</li>
<li>根节点(root)的左子树指向新节点（newNode）</li>
</ul></li>
<li><p><label><input
type="checkbox" />通过以上步骤完成了左子树深度+1，右子树深度-1</label></p></li>
<li><p><label><input type="checkbox" /><img
src="/img/picLib/AVLLeft.png" /></label></p></li>
<li><p><label><input type="checkbox" />```java private void
leftRotation() { System.out.println("left avl"); BinaryNode<E> node =
new BinaryNode<E>((E) this.tree.root.data); node.left =
this.tree.root.left; node.right = this.tree.root.right.left;</label></p>
<pre><code>      this.tree.root.data = this.tree.root.right.data;
      this.tree.root.left = node;
      this.tree.root.right = this.tree.root.right.right;
  &#125;</code></pre>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br><br><br><br><br><br><br><br><br><br><br>##### AVL右旋转<br><br>- [ ] 将插入后不平衡树向右倾斜<br><br>- [ ] 基本步骤【与左旋转对称】：<br><br>  - 创建一个新的节点，并赋值为根节点的值<br>  - 当前节点的右子树指向根节点的右子树<br>  - 当前节点的左左子树指向根节点左子树的右子树<br>  - 根节点的值赋值为根节点左子树的左子树<br>  - 根节点的左子树指向根节点左子树的左子树<br>  - 根节点的右子树指向新的节点<br><br>- [ ] ![](/img/picLib/avlRight.png)<br><br>- [ ] ```java<br>  <br>    	private void rightRotation(BinaryNode&lt;E&gt; node) &#123;<br>    		this.legalzationChild(false, node.left);<br>    		<br>    		BinaryNode&lt;E&gt; temp = new BinaryNode&lt;E&gt;((E) node.data);<br>    		temp.right = node.right;<br>    		temp.left = node.left.right;<br>    		<br>    		node.data = node.left.data;<br>    		node.left = node.left.left;<br>    		node.right = temp;<br>    	&#125;<br></code></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="avl双旋转">AVL双旋转</h5>
<ul class="task-list">
<li><p><label><input
type="checkbox" />对于某些数组再对根节点进行单旋转之前需要对其相应的子树进行判断是否符合单旋转，若不符合则需要进行双旋转，使子树合法，再进一步对根节点进行旋转</label></p></li>
<li><p><label><input type="checkbox" />旋转子树合法判断：</label></p>
<ul>
<li>若对节点（Node1）进行左旋转，需要该节点(Node1)的右子树(Node2)的左子树深度小于该右子树(Node2)的右子树深度</li>
<li>若对节点(Node1)进行右旋转，需要该节点(Node1)的左子树(Node2)的右子树深度小于该左子树(Node2)的左子树深度</li>
</ul></li>
<li><p><label><input type="checkbox" /><img
src="/img/picLib/doubleRoatation.png" /></label></p></li>
<li><p><label><input type="checkbox" />```java</label></p>
<p>private void legalzationChild(boolean left,BinaryNode<E> node) {
if(left) { int lDepth = 0; int rDepth = 0; if(node.left != null)lDepth =
this.getDepth(node.left); if(node.right != null)rDepth =
this.getDepth(node.right); if(lDepth &gt;
rDepth)this.rightRotation(node); } else { int lDepth = 0; int rDepth =
0; if(node.left != null)lDepth = this.getDepth(node.left); if(node.right
!= null)rDepth = this.getDepth(node.right); if(rDepth &gt;
lDepth)this.leftRotation(node); }</p>
<p>} private void rightRotation(BinaryNode<E> node) {
this.legalzationChild(false, node.left);</p>
<pre><code>  BinaryNode&lt;E&gt; temp = new BinaryNode&lt;E&gt;((E) node.data);
  temp.right = node.right;
  temp.left = node.left.right;

  node.data = node.left.data;
  node.left = node.left.left;
  node.right = temp;</code></pre>
<p>}</p>
<p>private void leftRotation(BinaryNode<E> node) {</p>
<pre><code>  this.legalzationChild(true, node.right);

  BinaryNode&lt;E&gt; temp = new BinaryNode&lt;E&gt;((E) node.data);
  temp.left = node.left;
  temp.right = node.right.left;

  node.data = node.right.data;
  node.left = temp;
  node.right = node.right.right;</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>#### 红黑树<br><br><br><br><br><br><br><br>#### 多路查找树<br><br>##### 二叉树与B树<br><br>- [ ] 二叉树的局限性：<br>  - 使用二叉树需要加载到内存，当二叉树的节点少时内存可以容忍，当二叉树结点个数较多时内存无法忍受<br>  - 当结点个数过多时：<br>    1. 内存消耗大<br>    2. 多次进行I/O操作时速度慢<br>    3. 树的高度过高<br>- [ ] 多叉树：<br>  - 当允许结点的个数大于2时，此时树升级为多叉树（Multiway Tree）<br>  - 多叉树的优势：通过重新组织结点，从而减少树的高度，提高查找效率<br>  - 当一个结点有两个子节点则此节点为2结点，若有3个子节点则为3结点<br>  - 通过多叉树可以对**大量**的数据进行快速查询<br>- [ ] B树的基本介绍：<br>  - 相关概念：<br>    1. 结点的度：结点子树的个数<br>    2. 树的度：所有结点中结点度最大的即为树的度<br>  - B树即为一种多叉树<br>  - B树及其延伸的树均为平衡树<br>  - B树B+树适用于数据库管理系统的表的索引<br><br><br><br><br><br>##### 2-3树<br><br>- [ ] 基本概念：2-3树是一种就简单的**B**树<br>- [ ] 结构特点：<br>  - 2-3树的所有叶子结点均在同一层**（所有B树均需要满足的特点）**<br>  - 二节点要么没有子节点，要么有两个子节点<br>  - 三节点要么没有子节点，要么有3个子节点<br>  - 2-3树是由二节点和三节点构成的树<br>- [ ] ![](/img/picLib/23t.png)<br><br><br><br><br><br><br><br>##### B树/B+树/B*树<br><br>- [ ] 误区：B树即B-Tree【**B-树就是B树**】<br>- [ ] 基本概念：<br>  - B树的阶：即B树最多子节点的个数（2-3树的阶为3，2-3-4树的阶为4）<br>- [ ] B+树基本概念：<br>  - B+树的所有信息存放在叶子结点而非叶子结点中不在存放信息<br>  - 所有关键词都存放在叶子结点的链表中，在链表中的索引即【稠密索引】<br>  - 非叶子结点的索引即【稀疏索引】<br>  - B+树叶子结点的链表连接在一起<br>- [ ] B*树：<br>  - 在非根非叶子结点之间添加指针使得兄弟非叶子结点之间可以互相连接<br><br><br><br><br><br><br><br><br><br>### 图<br><br>#### 基本介绍<br><br>- [ ] 为什么需要图：<br>  - 线性表局限于一个前驱和一个后继【一对一】<br>  - 树局限于一个前驱和多个后继【一对多】<br>  - 当需要多对多的关系时需要图的结构<br>- [ ] 相关概念：<br>  - 顶点(Vertex)<br>  - 边(edge)<br>  - 路径<br>  - 无向图<br>  - 有向图<br>  - 带权图<br>- [ ] 图的表示方式：<br>  - 邻接矩阵【二维数组】<br>  - 邻接表【数组 + 链表】<br><br><br><br>#### 图的创建即遍历<br><br>##### 邻接表【dfs + bfs】<br><br>```java<br>package Graph;<br><br>import java.util.ArrayList;<br><br>public class AdajacentMatrix&#123;<br>	private int cnt =  0;<br>	private boolean matrix[][];<br>	private boolean directed;<br>	public AdajacentMatrix(int cnt,boolean dire) &#123;<br>		// TODO Auto-generated constructor stub<br>		this.cnt = cnt;<br>		this.matrix = new boolean[cnt][cnt];<br>		for(int i = 0;i &lt; cnt;i++)this.matrix[i][i] = true;<br>		<br>		this.directed = dire;<br>	&#125;<br>	<br>	public void addEdge(int pos1,int pos2) &#123;<br>		if(directed)<br>			matrix[pos1][pos2] = true;<br>		else &#123;<br>			matrix[pos1][pos2] = true;<br>			matrix[pos2][pos1] = true;<br>		&#125;<br>	&#125;<br>	<br>	public void deleteEdge(int pos1,int pos2) &#123;<br>		if(directed)<br>			matrix[pos1][pos2] = false;<br>		else &#123;<br>			matrix[pos1][pos2] = false;<br>			matrix[pos2][pos1] = false;<br>		&#125;<br>	&#125;<br>	<br>	<br>	public void bfs(ArrayList queue,boolean vis[]) &#123;<br>		// TODO Auto-generated method stub<br>		<br>		while(!queue.isEmpty()) &#123;<br>			int vertex = (int) queue.get(0);<br>			queue.remove(0);<br>			<br>			for(int i = 0;i &lt; this.cnt;i++)<br>				if(this.matrix[vertex][i] &amp;&amp; !vis[i]) &#123;<br>					System.out.println(i);<br>					queue.add(i);<br>					vis[i] = true;<br>				&#125;<br>		&#125;<br>		<br>		<br>		<br>		<br>	&#125;<br>	<br>	public void dfs(int vertex,boolean vis[]) &#123;<br>		// TODO Auto-generated method stub<br>		vis[vertex] = true;<br>		System.out.println(vertex);<br>		for(int i = 0;i &lt; this.cnt;i++)<br>			if(this.matrix[vertex][i] &amp;&amp; !vis[i]) <br>				this.dfs(i, vis);<br>			<br>				<br>	&#125;<br>	<br>	public void traversal(boolean dfirst) &#123;<br>		boolean vis[] = new boolean[this.cnt];<br>		if(dfirst) &#123;<br>			for(int i = 0;i &lt; this.cnt;i++)<br>				if(!vis[i])this.dfs(i,vis);<br>		&#125;<br>		else &#123;<br>			ArrayList queue = new ArrayList();<br>			for(int i = 0;i &lt; this.cnt;i++)<br>				if(!vis[i]) &#123;<br>					System.out.println(i);<br>					vis[i] = true;<br>					queue.add(i);<br>					this.bfs(queue,vis);<br>				&#125;<br>		&#125;<br>	&#125;<br><br>	<br>	<br>	<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="邻接矩阵dfs-bfs">邻接矩阵【dfs + bfs】</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Graph;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdajacentTable</span> &#123;<br>	<br>	<span class="hljs-keyword">private</span> HashMap&lt;Object,ArrayList&lt;Object&gt;&gt; table = <span class="hljs-literal">null</span>;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dire;<br>	<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> pos1, <span class="hljs-type">int</span> pos2)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.dire) &#123;<br>			<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.table.containsKey(pos1))table.put(pos1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>			<span class="hljs-keyword">if</span>(table.get(pos1).contains(pos2))<span class="hljs-keyword">return</span>;<br>			<span class="hljs-keyword">else</span> table.get(pos1).add(pos2);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.table.containsKey(pos1))table.put(pos1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>			<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.table.containsKey(pos2))table.put(pos2, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>			<span class="hljs-keyword">if</span>(table.get(pos1).contains(pos2))<span class="hljs-keyword">return</span>;<br>			<span class="hljs-keyword">else</span> table.get(pos1).add(pos2);<br>			<br>			<span class="hljs-keyword">if</span>(table.get(pos2).contains(pos1))<span class="hljs-keyword">return</span>;<br>			<span class="hljs-keyword">else</span> table.get(pos2).add(pos1);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">AdajacentTable</span><span class="hljs-params">(<span class="hljs-type">boolean</span> dire)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-built_in">this</span>.dire = dire;<br>		<span class="hljs-built_in">this</span>.table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Object, ArrayList&lt;Object&gt;&gt;();<br>		<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> vertex, ArrayList vis)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		vis.add(vertex);<br>		System.out.println(vertex);<br>		<span class="hljs-keyword">for</span>(Object obj : <span class="hljs-built_in">this</span>.table.get(vertex)) &#123;<br>			<span class="hljs-keyword">if</span>(!vis.contains(obj)) &#123;<br>				<span class="hljs-built_in">this</span>.dfs(vertex, vis);<br>			&#125;<br>		&#125;<br>		<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(ArrayList queue, ArrayList vis)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">vertex</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) queue.get(<span class="hljs-number">0</span>);<br>			queue.remove(<span class="hljs-number">0</span>);<br>			<span class="hljs-keyword">for</span>(Object i : <span class="hljs-built_in">this</span>.table.get(vertex)) &#123;<br>				<span class="hljs-keyword">if</span>(!vis.contains(i)) &#123;<br>					System.out.println(i);<br>					vis.add(i);<br>					queue.add(i);<br>				&#125;<br>			&#125;<br>			<br>		&#125;<br>	&#125;<br>	<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(<span class="hljs-type">boolean</span> dfirst)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-type">ArrayList</span> <span class="hljs-variable">vis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>		<span class="hljs-keyword">if</span>(dfirst) &#123;<br>			<span class="hljs-keyword">for</span>(Object obj : table.keySet())<br>				<span class="hljs-keyword">if</span>(!vis.contains(obj))<br>					<span class="hljs-built_in">this</span>.dfs((Integer)obj, vis);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-type">ArrayList</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>			<span class="hljs-keyword">for</span>(Object obj : table.keySet())<br>				<span class="hljs-keyword">if</span>(!vis.contains(obj)) &#123;<br>					vis.add(obj);<br>					queue.add(obj);<br>					System.out.println(obj);<br>					<span class="hljs-built_in">this</span>.bfs(queue, vis);<br>				&#125;<br>					<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul class="task-list">
<li><label><input type="checkbox" />注意点：</label>
<ul>
<li>对于dfs或是bfs上锁的位置其实是相同的，均是在输出的位置进行上锁，避免了重复输出和重复遍历</li>
<li>dfs采用深度优先的思想：找到 --&gt; 上锁 --&gt; 进入dfs</li>
<li>bfs采用广度优先的思想需要配合队列适用：找到 --&gt; 上锁 ---&gt; 入队
---&gt; 等到该次循环完毕知乎堆子节点队列遍历</li>
<li>在bfs时队列<strong>候选子队列需要一直传递</strong>，当队列空时再返回call函数</li>
</ul></li>
</ul>
<h4 id="并查集">并查集</h4>
<h3 id="基本算法">基本算法</h3>
<h4 id="分治算法">分治算法</h4>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本概念：</label></p>
<ul>
<li>将大问题分成若干个问题相似，但规模小的问题，小问题解合并成大问题的解</li>
<li>基本步骤：
<ol type="1">
<li>分解</li>
<li>解决</li>
<li>合并</li>
</ol></li>
<li>由于分治的思想和递归思想不谋而合，因此大多数的分治问题可以通过递归的方法解决</li>
</ul></li>
<li><p><label><input type="checkbox" />汉诺塔问题</label></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hannoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n,String A,String B,String C)</span> &#123;<br>		<span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) &#123;<br>			System.out.println(A + <span class="hljs-string">&quot; ---&gt; &quot;</span> + C);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			hannoi(n - <span class="hljs-number">1</span>, A, C, B);<br>			System.out.println(A + <span class="hljs-string">&quot; ---&gt; &quot;</span> + C);<br>			hannoi(n - <span class="hljs-number">1</span>, B, A, C);<br>		&#125;<br>		<br>	&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="动态规划">动态规划</h4>
<ul class="task-list">
<li><label><input
type="checkbox" />将大问题分成规模小问题相似的小问题，通过获得小问题的最优解从而获得大问题的最优解</label></li>
<li><label><input
type="checkbox" />与分治法的区别：小问题不是相互独立的，而是相依赖的，即小问题的解需要用到更小的问题的解</label></li>
<li><label><input type="checkbox" />0-1背包问题 /
完全背包问题</label></li>
</ul>
<h4 id="字符串匹配算法">字符串匹配算法</h4>
<h5 id="暴力匹配">暴力匹配</h5>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本步骤：</label></p>
<ul>
<li>依次遍历母串，若母串[ i ] == 子串[ 0
]，则进行i++,j++直到母串结束或子串结束或字符不匹配</li>
<li>判断j == 子串.length - 1若是则找到返回i - j，否则未找到i = i - j +
1，j = 0</li>
<li>即只要发现匹配错误，就向前进1</li>
</ul></li>
<li><p><label><input type="checkbox" />```java static void
violientMatch(String str1,String str2) { int j = 0; for(int i = 0;i &lt;
str1.length();i++) { if(str1.charAt(i) == str2.charAt(0)) { while(i &lt;
str1.length() - 1 &amp;&amp; j &lt; str2.length() - 1 &amp;&amp;
str1.charAt(i) == str2.charAt(j)) { i++; j++; } if(j != str2.length() -
1) { i = i - j + 1; j = 0; } else { System.out.println(i - j); break; }
} } }</label></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>##### KMP<br><br>- [ ] 基本思想：<br><br>  - 根据**子串**的结构获得部分匹配表<br>  - 通过部分匹配表完成字符串的匹配<br>  - 即找到**最长公共前后缀**位置，再从该位置继续找<br>  - **val = next[pos] 的值表示从子串开始val个数与从pos开始向前val个数相同**<br>  - next数组的作用找到从头开始val个数 + 1的位置的元素与当前不相等的元素进行比较,若未找到，则继续找和此后缀最长的前缀位置替换至i - 1处，再从前缀 + 1处的元素比较<br><br>- [ ] ```java<br>  static public void kmpMatch(String str1,String str2) &#123;<br>  		int next[] = getNext(str2);<br>  		int j = 0;<br>  		for(int i = 0;i &lt; str1.length();i++) &#123;<br>  			while(j &gt; 0 &amp;&amp; str2.charAt(j) != str1.charAt(i))j = next[j - 1];<br>  			if(str1.charAt(i) == str2.charAt(j))j++;<br>  			if(j == str2.length() - 1) &#123;<br>  				System.out.println(i - j + 1);<br>  				return;<br>  			&#125;<br>  		&#125;<br>  		<br>  	&#125;<br>  	<br>  	static public int[] getNext(String str) &#123;<br>  		int next[] = new int[str.length()];<br>  		for(int i = 1,j = 0;i &lt; str.length();i++) &#123;<br>  			while(j &gt; 0 &amp;&amp; str.charAt(i) != str.charAt(j))j = next[j - 1];<br>  			if(str.charAt(i) == str.charAt(j)) &#123;<br>  				i++;j++;<br>  			&#125;<br>  			next[i] = j;<br>  		&#125;<br>  		return next;<br>  	&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="最小生成树">最小生成树</h4>
<h5 id="普利姆算法">普利姆算法</h5>
<ul class="task-list">
<li><p><label><input type="checkbox" />基本步骤：</label></p>
<ul>
<li>初始化选中一个结点v0,vis[v0] = true，加入结点集</li>
<li>从结点集种选中连接的边种最小的权值连接点v1，vis[v1] = true</li>
<li>重复2过程</li>
<li>只要保证新加的边的其中一点没有被选中过，就可以保证无回路生成：若加入边后有回路，当且仅当被选中的其中一点在树中，与点未被选中想违背，所以只要点没有被选中过则无回路</li>
</ul></li>
<li><p><label><input type="checkbox" />```java static final int minNum =
65535;</label></p>
<p>static public int prim(int map[][]) { boolean vis[] = new
boolean[map.length]; HashSet set = new HashSet();</p>
<pre><code>  vis[0] = true;
  set.add(0);

  int quality = 0;
  int min = minNum;



  while(set.size() != map.length) &#123;

      int findPoint = -1;
      int outNode = -1;
      for(int i = 0;i &lt; map.length;i++) &#123;
          for(int j = 0;j &lt; map.length;j++) &#123;
              if(vis[i] &amp;&amp; !vis[j] &amp;&amp; map[i][j] &lt; min) &#123;
                  min = map[i][j];
                  findPoint = j;
                  outNode = i;
              &#125;
          &#125;
      &#125;
      vis[findPoint] = true;
      quality += min;
      set.add(findPoint);
      min = minNum;
      System.out.println(outNode + &quot; --&gt; &quot; + findPoint);
  &#125;
  return quality;</code></pre>
<p>} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>  <br><br>##### 克鲁斯卡尔算法<br><br>- [ ] 难点：判断回路【只要结点的终点不相同则可以进行边的添加，否则不可以添加】<br><br>- [ ] ```java<br>  static public int getDst(int []dst,int i) &#123;<br>  		while(dst[i] != -1)i = dst[i];<br>  		return i;<br>  	&#125;<br>  	<br>  	static public int kruskal(int map[][]) &#123;<br>  		int dst[] = new int[map.length];<br>  		for(int i = 0;i &lt; dst.length;i++)dst[i] = -1;<br>  		boolean vis[] = new boolean[map.length];<br>  		int cnt = 0;<br>  		int quality = 0;<br>  		<br>  		PriorityQueue&lt;Edge&gt; queue = new PriorityQueue(Edge.class);<br>  		for(int i = 0;i &lt; map.length;i++) &#123;<br>  			for(int j = 0;j &lt; map.length;j++)<br>  				if(map[i][j] &lt; minNum)<br>  					queue.add(new Edge(i, j, map[i][j]));<br>  		&#125;<br>  		<br>  		<br>  		while(cnt != map.length - 1) &#123;<br>  			Edge edge = queue.pop();<br>  			int node1 = edge.list.get(0);<br>  			int node2 = edge.list.get(1);<br>  			int dst1 = getDst(dst, node1);<br>  			int dst2 = getDst(dst,node2);<br>  			if(dst1 != dst2) &#123;<br>  				cnt++;<br>  				quality += edge.w;<br>  				dst[dst1] = dst2;<br>  			&#125;<br>  			<br>  		&#125;	<br>  		<br>  		return quality;<br>  	&#125;<br>  class Edge implements Comparable&#123;<br>  	ArrayList&lt;Integer&gt; list = new ArrayList();<br>  	int w;<br>  	public Edge(int node1,int node2,int w) &#123;<br>  		// TODO Auto-generated constructor stub<br>  		this.list.add(node2);<br>  		this.list.add(node1);<br>  		<br>  		this.w = w;<br>  	&#125;<br>  	<br>  	@Override<br>  	public int compareTo(Object o) &#123;<br>  		// TODO Auto-generated method stub<br>  		Edge edge = (Edge)o;<br>  		if(this.w &lt; edge.w)return -1;<br>  		else if(this.w == edge.w)return 0;<br>  		else return 1;<br>  		<br>  	&#125;<br>  	@Override<br>  	public String toString() &#123;<br>  		// TODO Auto-generated method stub<br>  		return this.w + &quot;&quot;;<br>  	&#125;<br>  &#125;<br></code></pre></td></tr></table></figure></p></li>
<li><p><label><input
type="checkbox" /><strong>根据回路算法。在一棵树上只有终点的值是常量C，其余均是dst均是通向终点的路径</strong>，<strong>这样保证了在一颗树上加入新的结点时，更改的一定是终点</strong></label></p></li>
</ul>
<h4 id="最短路径">最短路径</h4>
<h5 id="迪杰斯特拉算法">迪杰斯特拉算法</h5>
<ul class="task-list">
<li><label><input
type="checkbox" />求出<strong>两点</strong>之间的最短路径</label></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">minNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">65535</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> temp)</span> &#123;<br>	<span class="hljs-keyword">if</span>(temp == start) &#123;<br>		System.out.println(start);<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		printPath(arr, start, arr[temp]);<br>		System.out.println(temp);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> map[][],<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span> &#123;<br>	<span class="hljs-type">boolean</span> vis[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[map.length];<br>	<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> start;<br>	vis[index] = <span class="hljs-literal">true</span>;<br>	<span class="hljs-type">int</span> nodeWeight[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[map.length];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nodeWeight.length;i++)nodeWeight[i] = minNum;<br>	nodeWeight[index] = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> path[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[map.length];<br>	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> minNum;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; map.length;i++) <br>			<span class="hljs-keyword">if</span>(!vis[i] &amp;&amp; nodeWeight[index] + map[index][i] &lt; nodeWeight[i]) &#123;<br>				nodeWeight[i] = nodeWeight[index] + map[index][i];<br>				path[i] = index;<br>			&#125;<br>				<br>		<span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; map.length;i++)<br>			<span class="hljs-keyword">if</span>(nodeWeight[i] &lt; min &amp;&amp; !vis[i]) &#123;<br>				min = nodeWeight[i];<br>				index = i;<br>			&#125;<br>		vis[index] = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">if</span>(index == end)<span class="hljs-keyword">break</span>;<br>		<br>	&#125;<br>	<br>	printPath(path, start, end);<br>	<span class="hljs-keyword">return</span> nodeWeight[end];<br>	<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="弗洛伊德算法">弗洛伊德算法</h5>
<ul class="task-list">
<li><p><label><input
type="checkbox" />求出所有点之间的最短路径</label></p></li>
<li><p><label><input type="checkbox" />基本原理：</label></p>
<ul>
<li>假设已知Vi到Vk之间的最短路径为Lik,Vk到Vj之间的最短路径为Lkj</li>
<li>已知当前的Vi到Vj之间的最短路径为Lij</li>
<li>则<strong>Lij = Min(Lij,(Lik + Lkj))</strong></li>
</ul></li>
<li><p><label><input type="checkbox" />```java static public void
floyd(int map[][]) { int path[][] = new int[map.length][map.length];
for(int i = 0;i &lt; map.length;i++) for(int j = 0;j &lt;
map.length;j++) path[i][j] = i;</label></p>
<pre><code>  for(int k = 0;k &lt; map.length;k++) &#123;
      for(int i = 0;i &lt; map.length;i++) &#123;
          for(int j = 0;j &lt; map.length;j++)
              if(map[i][k] + map[k][j] &lt; map[i][j]) &#123;
                  map[i][j] = map[i][k] + map[k][j];
                  path[i][j] = path[k][j];
              &#125;
      &#125;
  &#125;</code></pre>
<p>}</p>
<p>```</p></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ychhh-1114.github.io">Yue C.H.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ychhh-1114.github.io/2022/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://ychhh-1114.github.io/2022/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ychhh-1114.github.io" target="_blank">Yue C.H. Site</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Data-Struct/">Data Struct</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/a.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/23/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Java设计模式学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java设计模式学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/27/%E7%88%AC%E8%99%AB/" title="Python爬虫理论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python爬虫理论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/06/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/" title="Annotation Points"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="title">Annotation Points</div></div></a></div><div><a href="/2024/05/06/Redis%20Note/" title="Redis Note"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="title">Redis Note</div></div></a></div><div><a href="/2024/04/19/ssm_note/" title="SSM踩坑笔记 -（在更中）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-19</div><div class="title">SSM踩坑笔记 -（在更中）</div></div></a></div><div><a href="/2022/10/21/javaSpring/" title="JavaSpring学习笔记_2022年版"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-21</div><div class="title">JavaSpring学习笔记_2022年版</div></div></a></div><div><a href="/2022/03/23/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Java设计模式学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">Java设计模式学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/a.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yue C.H.</div><div class="author-info__description">去光荣的失败</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ychhh-1114"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ychhh-1114" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1325650083@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">线性结构特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">稀疏数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">数组循环队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">双向链表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">数组模拟栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BC%80-%E4%B8%AD%E7%BC%80-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">前缀 &#x2F; 中缀 &#x2F; 后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">前缀表达式（波兰表达式）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">中缀表达式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">后缀表达式（逆波兰表达式）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92recursion"><span class="toc-number">1.4.</span> <span class="toc-text">递归（Recursion）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.1.</span> <span class="toc-text">迷宫问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%A7%8D%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">排序种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">算法时间复杂度统计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">平均时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.2.2.</span> <span class="toc-text">最坏时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.6.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">2.8.</span> <span class="toc-text">排序算法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">3.2.</span> <span class="toc-text">插值查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E9%9D%9E%E5%86%B2%E7%AA%81%E6%B6%88%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">哈希表【非冲突消解】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E5%93%88%E5%B8%8C"><span class="toc-number">4.1.</span> <span class="toc-text">员工管理哈希</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-number">5.1.</span> <span class="toc-text">树结构基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">5.1.1.</span> <span class="toc-text">树的基本术语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%A0%91%E5%88%86%E6%9E%90"><span class="toc-number">5.1.2.</span> <span class="toc-text">数组，链表，树分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">后续遍历</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.2.3.</span> <span class="toc-text">顺序存储二叉树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">5.3.</span> <span class="toc-text">堆和堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">5.4.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E8%A7%A3%E5%8E%8B"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">赫夫曼解压</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%88%97%E6%A0%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">5.5.</span> <span class="toc-text">二叉排列树【二叉搜索树】</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">5.5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%88%97%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.5.2.</span> <span class="toc-text">二叉排列树的创建和中序遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">5.6.</span> <span class="toc-text">二叉平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-number">5.6.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#avl%E5%B7%A6%E6%97%8B%E8%BD%AC"><span class="toc-number">5.6.2.</span> <span class="toc-text">AVL左旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#avl%E5%8F%8C%E6%97%8B%E8%BD%AC"><span class="toc-number">5.6.3.</span> <span class="toc-text">AVL双旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5dfs-bfs"><span class="toc-number">5.6.4.</span> <span class="toc-text">邻接矩阵【dfs + bfs】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">5.7.</span> <span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">基本算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">分治算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.2.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">字符串匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D"><span class="toc-number">6.3.1.</span> <span class="toc-text">暴力匹配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">普利姆算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">6.5.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">6.5.1.</span> <span class="toc-text">迪杰斯特拉算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="toc-number">6.5.2.</span> <span class="toc-text">弗洛伊德算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/06/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" title="Mybatis逆向工程">Mybatis逆向工程</a><time datetime="2024-05-06T12:53:11.000Z" title="发表于 2024-05-06 20:53:11">2024-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/06/Redis%20Note/" title="Redis Note">Redis Note</a><time datetime="2024-05-06T12:51:11.000Z" title="发表于 2024-05-06 20:51:11">2024-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/06/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/" title="Annotation Points">Annotation Points</a><time datetime="2024-05-06T12:50:11.000Z" title="发表于 2024-05-06 20:50:11">2024-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/06/SpringBoot%20Note/" title="SpringBoot Note">SpringBoot Note</a><time datetime="2024-05-06T12:48:11.000Z" title="发表于 2024-05-06 20:48:11">2024-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/19/ssm_note/" title="SSM踩坑笔记 -（在更中）">SSM踩坑笔记 -（在更中）</a><time datetime="2024-04-19T10:14:21.000Z" title="发表于 2024-04-19 18:14:21">2024-04-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Yue C.H.</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><div class="aplayer no-destroy" data-id="7039308213" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>